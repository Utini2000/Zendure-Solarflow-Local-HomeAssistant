################################################################################
#                   ZENDURE SOLARFLOW CONTROL PACKAGE (V42.0)                  #
#             EDITION: DIAMOND LOGIC (SYSTEM SYNC & MEMORY GUARD)              #
################################################################################
#
# DESCRIPTION:
# Advanced local control for Zendure SolarFlow with Shelly 3EM.
# Features strict validation, safe math, and separate state/loop logic.
#
# REQUIREMENTS:
# - Zendure Hyper 2000 / SolarFlow 800 Pro (HTTP API enabled)
# - Shelly Pro 3EM (Grid measurement)
# - Integration "Forecast.Solar"
#
# STRATEGY (Managed by Logic Manager):
# - WINTER: Stop 20% | Emerg Start 10% -> Charge to 15% (300W Soft)
# - SUMMER: Stop 10% | Emerg Start 7%  -> Charge to 10% (300W Soft)
# - ALWAYS: Hardware Limit (minSoc) fixed at 5% (Panic Line).
# - ALWAYS: Soft Start (<12% SoC) limits Power to 300W.
# - SAFETY: Heat Protection Bypass starts at 45°C (was 55°C).
#
# NETWORK STABILITY:
# - Polling: 15s | Timeout: 30s | No forced updates (Anti-DDoS).
#
# COMPLETE CHANGELOG:
# V1.0  Initial release. Basic HTTP API connection.
# V2.0  Added basic zero-export logic based on Shelly 3EM grid sum.
# V3.0  Implemented "Failsafe Mode": Fallback output if Shelly data is missing.
# V4.0  Switch to "Package" format & added Dashboard Helpers (Input Numbers).
# V4.1  Added "Emergency Charge" (AC Charge) logic for critical battery levels.
# V4.2  Introduced Seasonal Logic (Winter 20% / Summer 10% MinSoC).
# V4.3  Added "Schonmodus" (Bypass): 90% Solar pass-through between MinSoC and 30%.
# V5.0  Performance Fix: Moved monitoring to separate automation to reduce spam.
# V6.0  Added "Option 1" (Weather Forecast): Smart Emergency Charge.
#       Added "Option 2" (Calibration): Weekly top-balancing logic.
#       Added "Option 3" (Winter Protection): Standby if Temp < 0°C.
# V6.1  "Smart Calibration": Only force charge if not full for 7 days.
# V6.2  "Saturation Mode": Force min. 150W output if Battery > 98% and Solar > 150W.
# V6.3  High-Speed Update: Loop interval reduced to 5s. Added Delta-Check logic.
# V6.4  Precision Update: Hysteresis configurable via Slider.
# V6.5  BUGFIX: Temp Calculation (Deci-Kelvin to Celsius). Fixed Winter Protection.
# V7.0  MAJOR ARCHITECTURE UPDATE: Split Logic (Loop vs State), Safe Templates (.get),
#       Command De-duplication (Last Sent Memory), Grid Bias & Fast Clamp.
# V8.0  CRITICAL FIXES & POLISH:
#       - Corrected Grid Bias Math (Subtraction instead of Addition).
#       - Fixed Input Number Range (Allow -2 for State Machine).
#       - Security: Failsafe now strictly checks for valid SN before acting.
#       - Stability: Control Loop now bases math on 'last_sent' to eliminate lag.
#       - Fast Clamp: Improved trigger condition for immediate export prevention.
#       - Resync: Auto-detects reboot/drift to reset internal memory.
# V9.0: CRITICAL BUGFIXES & FINAL POLISH:
#       - Jinja Comment Fix: Replaced '#' with '{# #}' to prevent calculation errors.
#       - Safety Gate: Execution block now explicitly demands valid SN (sn_ok).
#       - Robustness: All payloads strictly cast to |int.
#       - Logic: Resync mechanism automatically handles Reboot/API-Failures
#         (replacing the need for complex HTTP status checks).
# V10.0: POLISHING & HARDENING:
#        - Self-Healing Memory: Automatically commits "Resync" values to memory
#          if drift/reboot is detected.
#        - Smart Refresh: Forces an immediate sensor update after writing to the API
#          to minimize the "stale data" window.
#        - Logic Optimization: Cleaned up action sequences for maximum determinism.
# V11.0: PRODUCTION HARDENING:
#        - Negative Guard: base_value calculation now explicitly handles negative
#          memory codes (like -2) to prevent math errors after restarts.
#        - Traffic Optimization: Reduced Sensor Polling to 10s (relying on
#          smart memory for speed and on-demand refresh for updates).
#        - Logic Cleanup: merged drift and negative checks for efficiency.
# V11.1: FINAL SAFETY UPGRADE:
#        - Explicit Action Gating: Execution block now requires 'zendure_ok'
#          AND 'sn_ok' to fire. This prevents writes even if calculation logic
#          is accidentally modified in the future (Defense in Depth).
# V11.2: Dashboard Fix (Sanitization).
# V11.3: DATA PURITY FIX:
#        - Problem: API reports positive values for BOTH Charge and Discharge
#          sensors simultaneously (noise/measurement error). This confuses the
#          Energy Dashboard (counting charge as discharge).
#        - Fix: Implemented "Net Flow Logic". The script calculates the net
#          difference (Input - Output).
#          If Net > 0 -> Report Charging, force Discharging to 0.
#          If Net < 0 -> Report Discharging, force Charging to 0.
#          This makes the sensors mutually exclusive, as per physics.
# V11.4: PERFECT MERGE:
#        - Combines V11.2 and V11.3 logic.
#        - Raw sensor data is FIRST sanitized (clipping negatives to 0)
#        - THEN the net flow is calculated.
#        - Prevents "Ghost Charging" caused by negative noise on the output channel.
# V11.5: SENSOR SWAP FIX:
#        - Diagnosis: User reported that Charging Energy appears as Discharging
#          in Home Assistant, despite correct Dashboard config.
#        - Fix: SWAPPED the API mapping in the Template Sensors.
#          "Pack Input Power" (Charge) now reads 'outputPackPower' from API.
#          "Pack Output Power" (Discharge) now reads 'packInputPower' from API.
#          This aligns the script with the device's actual reporting behavior.
# V11.6: STRATEGY UPDATE:
#        - Summer Soft-Stop set to 8% (Logic Manager).
#        - Emergency Charge Start set to 6% (Buffer before Hardware Limit).
#        - Hardware Limit remains 5% (in Zendure App).
#        - Emergency Charge Stop remains 15% (Healthy Hysteresis).
# V11.7: STABILITY UPDATE:
#        - Removed version numbers from Automation Aliases and IDs.
#        - Ensures that recorder/logbook exclusions in configuration.yaml
#          remain valid even after future script updates.
# V11.8: NETWORK STABILITY FIX:
#        - Diagnosis: User reported periodic "drops to 0" on all sensors.
#          Cause: The aggressive "Write + Immediate Read" logic overwhelmed the
#          ESP32 chip of the Zendure, causing connection drops.
#        - Fix 1: Removed 'homeassistant.update_entity' (Force Refresh).
#          We now rely purely on internal memory for fast control, giving the
#          device time to breathe.
#        - Fix 2: Increased Polling Interval to 15s.
#        - Fix 3: Updated Template Sensors to return 'unavailable' instead of '0'
#          when API data is missing. This prevents "sawtooth" graphs.
# V12.0: DUAL DEVICE ARCHITECTURE (MAJOR RELEASE):
#        - Complete rewrite to support TWO Zendure units simultaneously.
#        - Introduced "Smart Balancing": Dynamically splits load between units.
#        - New "System Sensors": Total Solar & Average SoC calculations.
#        - Architecture: Dual-State Machine & Dual-Control Loop.
# V12.1 - V12.7: TUNING & SAFETY:
#        - Loop Tuning: Settled on 5s Control Loop for high responsiveness.
#        - Safety: Logic Manager restricted to run only on boot/daily.
#        - Jinja Hardening: Replaced comments to prevent calculation errors.
# V12.8: FAULT TOLERANCE (DEGRADED MODE):
#        - System Sensors now degrade gracefully. If one unit fails, the system
#          continues running with the remaining unit's data (no crash).
# V12.9 - V12.13: STRICT VALIDATION (BULLETPROOF):
#        - Implemented 'is mapping' guards against malformed API data.
#        - State Machine now strictly verifies 'OK' status before writing.
#        - Temp Logic: Safe fallbacks to prevent accidental winter-mode triggers.
# V12.14: PROTOCOL UPGRADE (ULTIMATE PRO):
#        - Switched write protocol from 'chargeMaxLimit' to 'acMode' (Official API).
#        - Fixed Bypass Math: If one unit is bypassed, other takes 100% load.
#        - HTTP Safety: Added response status checks (200 OK) for memory updates.
# V12.15: TIMING & SAFETY:
#        - Timing Tuning: Sensor Scan 10s / REST Timeout 3-4s (Non-blocking).
#        - Forecast Safety: Default changed to 0 (Pessimistic) to force
#          emergency charge if API is unreachable.
# V12.16: PASSTHROUGH PRIORITY:
#        - Logic Change: Solar Passthrough is now ALWAYS allowed (if online).
#        - Winter/LowSoC logic now only blocks Battery Discharge, not Output.
# V12.18: ARCHITECTURE SHIFT (DIAMOND):
#        - Failsafe Logic moved to Target Calculation (respects Battery limits).
#        - Added High-Temp Cutoff (>55°C) PER UNIT to protect hardware.
# V12.19: OBSIDIAN STABILITY:
#        - Added "Leakage Buffer": Uses only 90% of Solar Input if battery is
#          blocked, to prevent accidental battery drain due to measurement lag.
# V12.20: GHOST LOAD FIX:
#        - 'total_base' calculation now ignores offline units to prevent drift.
#        - Added System Watchdog (Notification if both units offline > 3min).
# V12.22: TELEGRAM EDITION:
#        - Added Telegram Notifications for all critical system events:
#          (Calibration Start/Stop, Shelly Failsafe, Recovery, Total Failure).
# V12.24: SYNC PRECISION:
#        - Synchronized polling (10s) for both units to ensure data coherence
#          during calculation (preventing "Apples & Oranges" math).
# V12.26: FLASH GUARD (SMARTMODE):
#        - Activates 'smartMode: 1' on boot/daily. Writes changes to RAM instead
#          of Flash memory, extending hardware lifespan significantly.
#        - Fixed "Negative Memory" bug (clamped last_sent to 0).
# V12.27: REBOOT GUARD:
#        - Forces SmartMode immediately when a unit comes online to ensure
#          flash protection is active instantly after power loss.
# V12.29: FULL AUTHORITY (HARDWARE UNLOCK):
#        - Season Manager now forces internal device limits (inverseMaxPower,
#          chargeMaxLimit) to 800W to prevent firmware-side throttling.
#        - Sets Grid Standard to 2 (Austria).
# V12.30: MANUAL MODE PROTECTION (HANDS-OFF):
#        - State Machine now respects 'Zendure Automatik Aktiv'.
#        - If Auto is OFF, the script will NOT touch the device settings during
#          HA Restarts or Device Recovery, preserving manual overrides.
# V12.31 (User Request):
# 1. NEW SENSOR: Added 'sensor.solarflow_system_total_output'.
#    - Sums up the output limit of Unit 1 and Unit 2.
#    - Handles unavailable units gracefully (treats them as 0).
#    - Perfect for Dashboard visualizations (Total House Injection).
# V12.33 (User Precision Request):
# 1. NET BATTERY SENSORS: Added calculation for real Battery Charge/Discharge.
#    - Differentiates between Solar-Direct-Consumption and actual Battery Charging.
#    - Sums up both Units for a unified "Home Battery" view.
# 2. RIEMANN INTEGRATORS: Updated to provide clean kWh for the Energy Dashboard.
# V12.36:
# 1. SENSOR STABILITY: Removed the "Default 0" fallback.
#    - If WiFi drops (Status unavailable), sensors now report 'unavailable'.
#    - Prevents graphs from spiking down to 0% and triggering false logic.
# 2. LOGBOOK CLEANUP: Added exclusion recommendations for RAW sensors to
#    prevent spamming the logbook with "became unavailable" messages.
# PREVIOUS:
# - Entity IDs restored, Manual Mode Protection, SmartMode, Flash Guard.
# V12.38 (Optimization):
# 1. DUAL BALANCING STRATEGY:
#    - Phase A (Passthrough): Split Output proportional to SOLAR Input.
#      (Unit with more Sun takes the heavy lifting).
#    - Phase B (Discharge): Split remaining Output proportional to SOC.
#      (Unit with 80% charge works harder than unit with 20% charge).
#      -> Result: Both batteries drain evenly and reach 0% together.
# PREVIOUS:
# - Manual Protect, Real Power Stats, Safety Math, Flash Guard.
# V12.42 (Performance Tuning):
# 1. HIGH SPEED POLLING: REST sensors now scan every 6 seconds (beating Cloud).
# 2. SIGNAL HOLDING (CRITICAL): If the rapid polling causes a "Busy" dropout,
#    the sensors RETAIN the last value instead of dropping to 0 or unavailable.
#    -> This allows aggressive polling without graph glitches.
# 3. PRECISION: Hysteresis default lowered to 2W for fine-grained control.
# 4. SAFETY: All V12.41 Safety Shields (800W Limit, Calibration Fix) included.
# V12.43 (Single Unit Compatibility):
# 1. HYBRID SUMMING: System Total Sensors now treat missing/offline units as 0
#    instead of breaking the calculation with 'unknown'.
#    -> Works perfectly with 1 Unit OR 2 Units.
# 2. RETAINED: High-Speed Polling (6s), Signal Holding, Safety Shields.
# V12.45 (Performance Optimization):
# 1. SMART WRITES: Replaced "Double Tap" (blind retries) with "Smart Retry".
#    The script now checks the HTTP code (200 OK). It only resends the command
#    if the first attempt failed.
#    -> Reduces API traffic by ~50% for setting changes.
# 2. RETAINED: All Logic Guards (V12.44), Safety Shields, and Hybrid Mode.
# V12.47 (Limit Testing):
# 1. ULTRA POLLING: Reduced REST scan_interval to 4 seconds.
# 2. SHORT TIMEOUT: Reduced HTTP timeout to 3 seconds.
#    -> If device is busy, we fail fast and retry immediately next cycle.
# 3. FAST LOOP: Control Loop now runs every 3 seconds (was 5).
#    -> Reduces processing latency to the absolute minimum.
# 4. RETAINED: Syntax Fixes, Logic Guards, Hybrid Mode & Safety Shields.
# V12.48 (Deprecation Fix):
# 1. INTEGRATED HEARTBEAT: The 'Zendure Heartbeat' sensor is now built-in
#    using the modern 'template:' syntax. This fixes the "2026.6" warning.
#    -> Please remove any manual/legacy sensor definitions you added previously.
# 2. RETAINED: Ultra-Speed Tuning (4s/3s), Safety Shields, Hybrid Mode.
# V12.48b (SpeedFix):
# 1. Decrease Speed for stability (10 / 8)
# V12.49 (Logic Bugfix):
# 1. SMART CALIBRATION STOP: Added battery level triggers to the calibration
#    check. The system now automatically stops calibration mode as soon as
#    batteries reach 100%, instead of waiting for the next day.
# 2. STABILITY DEFAULTS: Set scan_interval to 10s and timeout to 8s by default
#    to prevent network congestion ("60s gaps").
# 3. RETAINED: Integrated Heartbeat, Safety Shields, Hybrid Mode.
# UPDATES V12.50 (Feature Complete):
# 1. FIRMWARE SENSORS: Added display sensors for Master Version.
#    (Note: HA handles de-duplication automatically, so no extra load).
# 2. STABILITY: Fixed timing at 10s Interval / 8s Timeout.
# 3. RECOMMENDATION: Add the 'Status Raw' sensors to your recorder/exclude
#    list in configuration.yaml to save disk space.
# UPDATES V12.51 (Clean Up):
# 1. REMOVED FIRMWARE SENSORS: Your device model (EEA1...) does not broadcast
#    firmware version via local API. Removed the empty sensors to keep UI clean.
# 2. STABILITY: Retained the proven 10s Interval / 8s Timeout.
# 3. LOGIC: Retained Auto-Stop Calibration and Safety Shields.
# UPDATES V12.53 (Smart Charging):
# 1. SOFT LANDING CURVE: During Calibration/Emergency charge, the script now
#    monitors SoC per unit and throttles power dynamically:
#    - < 90%: Max 400W (Fast Charge)
#    - 90-97%: Max 200W (Gentle Approach)
#    - > 97%: Max 100W (Final Balancing Phase)
# 2. PV PRIORITY: Confirmed that system uses available Solar first, then Grid.
# 3. RETAINED: All stability fixes (10s/8s) and Safety features.
# UPDATES V13.1 (Community Feedback & Tuning):
# 1. NO-DRIFT LOGIC: Removed the "Drift Check" based on the lagging API sensor.
#    The script now trusts the 'input_number' and relies on the Grid Meter (Shelly)
#    feedback loop to correct deviations. Eliminates double-sending commands.
# 2. UNIVERSAL SOFT-LANDING: The logic to throttle charging speed (>90% SoC)
#    is now applied to DAILY SOLAR CHARGING via 'chargeMaxLimit', not just
#    emergency mode. Improves cell balancing significantly.
# 3. TUNING:
#    - Eco-Gate increased to 45W (Higher efficiency).
#    - Harvest Mode limited to 300W (User preference).
# UPDATES V13.4 (Optimized Speed):
# 1. INTERVAL: Set to 5 seconds.
#    - You correctly identified that logic stability prevents oscillation, not just timing.
#    - 5s is chosen to be responsive to clouds but protect the ESP32 from overload
#      (avoiding the 'unknown' dropouts seen in logs).
# 2. LOGIC: Uses the robust V12/V13.3 Sensor-Feedback logic:
#    Target = Reported_Output + Grid_Import. This is mathematically stable even
#    if polled frequently.
# 3. FEATURES: All Pro features active (Eco-Gate 45W, Soft-Landing, Harvest 300W).
# UPDATES V13.7 (Cleanup):
# 1. REMOVED SENSOR: 'SolarFlow System Temp' deleted as requested. Logic relies
#    solely on individual unit temps (t1/t2) which is safer and cleaner.
# 2. CORE FEATURES (Retained):
#    - 5s Interval / 4s Timeout (Turbo but Safe)
#    - Physical Charge/Discharge Measurement (Dashboard accurate)
#    - Eco-Gate (45W) & Harvest Mode (300W)
#    - Drift-Check Stability Logic
# UPDATES V14.0 (Final Stability Polish):
# 1. GHOST-LOAD FIX: The control loop now explicitly ignores the 'last_sent'
#    memory of OFFLINE units. Previously, an offline unit would retain its
#    last value (e.g., 400W) in the math, causing the other unit to over-
#    compensate indefinitely.
# 2. STATE MACHINE CONFLICT FIX: Removed the logic that forced 'Output: 0'
#    during normal operation updates. The State Machine now ONLY manages
#    Settings (MinSoc, etc.), leaving Output control exclusively to the Loop.
#    This prevents fighting/glitches between the two automations.
# 3. FAILSAFE MESSAGE: Updated notification text to "PV only" to correctly
#    reflect that battery discharge is blocked when Shelly is offline.
# 4. TUNING: Hysteresis default set to 5W (User Request).
# 5. RETAINED: 5s Interval, Physical Sensors, Drift-Check Logic.
# UPDATES V14.0 (Final Stability Polish):
# 1. GHOST-LOAD FIX: The control loop now explicitly ignores the 'last_sent'
#    memory of OFFLINE units. Previously, an offline unit would retain its
#    last value (e.g., 400W) in the math, causing the other unit to over-
#    compensate indefinitely.
# 2. STATE MACHINE CONFLICT FIX: Removed the logic that forced 'Output: 0'
#    during normal operation updates. The State Machine now ONLY manages
#    Settings (MinSoc, etc.), leaving Output control exclusively to the Loop.
#    This prevents fighting/glitches between the two automations.
# 3. FAILSAFE MESSAGE: Updated notification text to "PV only" to correctly
#    reflect that battery discharge is blocked when Shelly is offline.
# 4. TUNING: Hysteresis default set to 5W (User Request).
# 5. RETAINED: 5s Interval, Physical Sensors, Drift-Check Logic.
# FINAL CONFIGURATION V14.3:
# 1. MIN CHANGE FILTER (10W): Set default to 10W. This filters out the 7-8W
#    measurement noise seen in logs, preventing unnecessary "micro-adjustments"
#    while still reacting instantly to real loads (lights, appliances).
# 2. HYSTERESIS (5W): Kept at 5W to define the target precision band.
# 3. GRID BIAS (10W): Kept at 10W import target to prevent accidental export.
# 4. SAFETY & STABILITY: Includes all V14 fixes (Ghost-Load, State Machine,
#    Calibration Watchdog, Physical Sensors).
# UPDATES V14.4 (Network Fix):
# 1. SCAN INTERVAL: Increased from 5s to 10s.
#    - Reason: User logs showed massive timeouts. The ESP32 needs time to breath.
# 2. TIMEOUT: Increased from 4s to 9s.
#    - Reason: Prevents "unavailable" states just because the stick is slow.
# 3. CONTROL LOOP: Slowed down to 10s.
#    - Reason: Synchronizes with the sensor update rate.
# SWITCH TO MQTT
# SYSTEM SUMMARY:
# Unit 1 (Hub): HUB1_SERIAL_NUMBER  (IP: HUB1_IP_ADDRESS)
# Unit 2 (Hub): HUB2_SERIAL_NUMBER  (IP: HUB2_IP_ADDRESS)
# STRATEGY:
# 1. READ: Via MQTT (Real-time, Push, No Polling-Stress).
# 2. WRITE: Via HTTP REST (Reliable Control).
# FIX V15.3:
# - Corrected MQTT Topic for Output Limit (moved from 'sensor' to 'number').
# FEATURES V16:
# 1. TURBO TRIGGER: Reacts instantly to Shelly Power changes (Latency < 1s).
# 2. HEALTH CHECK: Monitors Cell Imbalance (minVol vs maxVol).
# 3. SAFETY: Noise Filter prevents API Spamming despite Turbo Trigger.
# UPDATES V16.2:
# 1. REMOVED DAMPING: Direct 1:1 correction for maximum speed.
# 2. FIXED BASE LOGIC: Calculation now strictly uses 'last_sent' (internal memory)
#    instead of waiting for slow MQTT feedback. This prevents the logic from
#    "resetting" itself during rapid changes.
# 3. SEPARATED HEALING: Drift check moved to separate automation.
# MAJOR UPGRADE V17.0:
# - DATASOURCE: Switches from Hub-Sensors ("packInputPower") to direct
#   Battery-BMS-Sensors ("batcur", "power", "maxTemp").
# - DASHBOARD FIX: Uses Battery Current (+/-) to strictly separate
#   Charge vs. Discharge energy. No more guessing.
# - SAFETY: Uses real Battery Temperature for Cold-Weather protection.
# HARDWARE MAPPING:
# Hub 1: HUB1_SERIAL_NUMBER <-> Bat 1: BAT1_SERIAL_NUMBER
# Hub 2: HUB2_SERIAL_NUMBER <-> Bat 2: BAT2_SERIAL_NUMBER
# UPDATES V18.2:
# - NEW AUTOMATION: "Anti-Drift Watchdog". Checks if the internal memory
#   diverges from the real device state for > 60 seconds. If yes -> Resync.
#   This fixes issues where external changes (App) or lost packets caused offsets.
# - REFINED LOOP: Removed the "Instant Memory Healing" from the main loop to
#   prevent false positives during MQTT lag (the 30s delay issue).
# - CORE: Keeps Balancing (V18.0) and Math-Energy (V16.11).
# UPDATES V19.0 (Response to Deep Review):
# 1. SMART ALLOCATION: If one unit is offline/blocked, the other takes 100% load.
#    (Fixes the "50% Trap" where system stayed in import).
# 2. PASSTHROUGH MODE: Between SoC Bypass (30%) and Off (10%), battery discharge
#    is blocked, BUT Solar Passthrough is allowed! (Previously hard blocked).
# 3. TRAFFIC CONTROL: Settings are only written if they actually need to change.
#    (Prevents ESP32 overload/timeouts).
# 4. FAILSAFE FIX: If Shelly is offline, we output 'failsafe_watt' via Passthrough
#    or Battery (depending on SoC), ensuring base load coverage.
# UPDATES V19.1:
# - SUMMER STRATEGY:
#   - Bypass (Protection) Mode starts at 10% (was 30%).
#   - Hard Cutoff at 8%.
#   -> Result: You can discharge down to 10% every night in summer.
# - WINTER STRATEGY (Unchanged):
#   - Bypass at 30% (to protect chemistry in cold).
#   - Hard Cutoff at 20%.
# FINAL CONFIGURATION V20.1:
# - LOGIC: "The Masterpiece" (Smart Redistribution & Passthrough).
# - STABILITY: "The Rock" (10s Timeouts + Crash Protection).
# - SEASON PROFILE:
#   - SUMMER: Discharge down to 8%. Bypass (Passthrough only) 8%-15%.
#   - WINTER: Discharge down to 20%. Bypass (Passthrough only) 20%-25%.
# - MAINTENANCE: Auto-Calibration every 14 days.
# BUGFIX V20.2:
# - REMOVED DUPLICATE SENSORS: "Battery Level Hub" for Unit 1 & 2 were defined
#   twice in the MQTT section, causing the "unique ID already exists" error.
# - RETAINED: All "Masterpiece" Logic (Smart Balancing, Safety, Timeout-Proof).
# UPDATES V21.0 (Based on Expert Feedback):
# 1. FAIL FAST: Loop Interval increased to 6s. REST Timeout reduced to 3s.
#    -> Prevents "Thread Pile-Up" in Home Assistant if WiFi is laggy.
# 2. COLD CHARGE PROTECTION: Dynamic Charging Limit based on Temperature.
#    - Temp < 5°C: Max 100W (Trickle Charge)
#    - Temp 5-10°C: Max 300W (Slow Charge)
#    - Temp > 10°C: Full Power (800W)
# 3. SAFETY CLAMP: If Internal Memory drifts >50W from Real Output (MQTT),
#    the loop auto-syncs immediately using the Real Output value.
# 4. FLASH GUARD: State Machine triggers dampened to prevent setting-spam.
# 5. RETAINED:
#    - Summer Bypass 15% / Winter Bypass 25%
#    - Calibration every 14 Days
#    - Smart Redistribution Logic (Masterpiece)
# UPDATES V21.1 (Final Polish based on Deep Review):
# 1. DUPLICATE FIX: Removed duplicate MQTT definitions causing Log Errors.
# 2. SYSTEM SOC: Logic now ignores offline units (0%) for average calculation.
#    (Prevents false Emergency triggers if one unit disconnects).
# 3. BMS TEMP: Added Battery BMS Temp sensors (Unit 1 & 2) and switched
#    safety logic to prioritize BMS Temp over Hub Temp (More accurate).
# 4. EMERGENCY LOGIC: Added explicit STOP condition (High SoC or Good Forecast).
# 5. NEGATIVE MEMORY: Control Loop now clamps 'last_sent' to 0 to prevent
#    math glitches after special commands (-2).
# UPDATES V21.4:
# 1. OSCILLATION FIX: Increased "Safety Clamp" threshold from 50W to 100W.
#    - Reason: Analysis showed "Sawtooth" patterns because the 50W limit was
#      triggering constantly due to device lag (reporting delay).
#    - Result: The loop tolerates lag better and stops jumping wildly.
# 2. RETAINED: 15%/25% Bypass, 14-Day Calibration, Smart Redistribution.
# 3. VERIFIED: Exit-Strategy and Cold-Charge Logic are active.
# UPDATES V21.4:
# 1. OSCILLATION FIX: Increased "Safety Clamp" threshold from 50W to 100W.
#    - Reason: Analysis showed "Sawtooth" patterns because the 50W limit was
#      triggering constantly due to device lag (reporting delay).
#    - Result: The loop tolerates lag better and stops jumping wildly.
# 2. LOG CLEANUP: Hardened all sensors against 'unknown' values during boot.
#    (Fixes "ValueError: invalid literal" in Home Assistant logs).
# 3. RETAINED: 15%/25% Bypass, 14-Day Calibration, Smart Redistribution.
# 4. VERIFIED: Exit-Strategy and Cold-Charge Logic are active.
# UPDATES V22.1:
# 1. REMOVED SAFETY CLAMP: The logic no longer compares "Memory" vs "Real Sensor".
#    - Reason: Hardware lag caused false positives (>100W diff), leading to
#      sawtooth oscillations.
#    - Result: The script now fully trusts its internal memory (last_sent).
#      This results in perfectly smooth target curves, even if the device lags.
# 2. RETAINED:
#    - 6s Loop / 3s Timeout (Fail Fast)
#    - Exit Strategy & Offline Guard
#    - Winter/Summer Bypass & Calibration
# UPDATES V22.2:
# 1. REMOVED SAFETY CLAMP: The logic now fully trusts 'last_sent' memory.
#    - Reason: Hardware lag caused false "Drift" alerts, resetting the target
#      and creating sawtooth waves. Trusting memory fixes this completely.
# 2. OFFLINE HARD-LOCK: If a unit is offline, its Capacity (cap) is forced to 0.
#    - Result: The Load Balancer automatically shifts 100% of the load to the
#      remaining active unit. No "50% Trap".
# 3. MATH SAFETY: Clamped 'last_sent' to 0 in the loop calculation to prevent
#    special codes (-2) from leaking into the power formula.
# 4. RESTORE STATE: Removed 'initial: false' from booleans so Home Assistant
#    remembers if Emergency Mode was active after a reboot.
# FINAL STABLE VERSION:
# - LOGIC: Pure Memory Trust (No Safety Clamp) for maximum smoothness.
# - SAFETY: Type-Safe templates against 'unknown' sensor values.
# - DUAL BALANCING: Proportional to SoC, with 100% failover if one unit is offline.
# - EXIT STRATEGY: Hard-reset to acMode 2 when Emergency/Calibration ends.
# UPDATES V22.4:
# 1. ANTI-CONGESTION: Increased Loop interval to 8s.
#    - Reason: Prevents "Already running" errors. A full cycle with two 3s
#      timeouts now fits comfortably into the 8s window.
# 2. PARALLEL MODE: Switched from 'single' to 'parallel' with max 2 threads.
#    - Result: Even if one cycle hangs due to a timeout, the next one can start.
# 3. HYSTERESIS BRAKE: Implemented the 5W hysteresis.
#    - Result: If the required change is minimal, no REST command is sent.
#      Reduces WiFi traffic and ESP32 load significantly.
# UPDATES V23.2:
# 1. EEPROM SAFETY: Restored explicit 'set_smartmode' command and implemented
#    the "Double-Send" logic in Season Manager (Start/Season change).
#    This ensures the device accepts the mode correctly without corrupting RAM/EEPROM.
# 2. ... (Alle Updates aus V23.1 sind weiterhin enthalten)
# FINAL CHANGELOG V23.4:
# 1. MATH HARDENING: Every single arithmetic operation is now explicitly cast
#    to int/float to prevent "int+str" crashes under any circumstance.
# 2. LOGIC SAFETY: Bypass Latch & Emergency Manager now check 'is_number()'
#    before acting. Prevents "0% Phantom Trigger" when sensors are unavailable.
# 3. DEBOUNCE: Added 1s delay to Turbo-Export trigger to filter noise.
# 4. PORTABILITY: Switched to 'is_number(x)' function style for better compatibility.
# CHANGELOG V24.1:
# 1. AC-CHARGE FIX: Added 'gridInputPower' sensors to correctly track Emergency
#    Charging and Calibration in the Energy Dashboard.
# 2. TUNING: Loop slowed to 8s (WLAN relief), REST Timeout reduced to 3s (Fail Fast).
# 3. SAFETY: Implemented 'is_number()' function checks globally.
# 4. LOGIC: Added 90% Leakage Buffer in Bypass Mode to protect battery.
# 5. CLEANUP: Removed unused input helpers.
# 6. MATH: Hardened calculations with explicit brackets.
# 7. STATS: Added 'state_class: measurement' for all power sensors.
# 8. HYSTERESIS: Set default to 5W for precision.
# CHANGELOG V25.0:
# 1. NEW FEATURE: "Sync Memory from OutputLimit". The script now listens to
#    MQTT updates from the device. If a REST command times out but the device
#    accepted the value, this automation updates the internal memory instantly.
#    -> Fixes "Drift" caused by lost HTTP responses.
# 2. TUNING: REST Timeout increased to 10s (standard) to be more patient with
#    slow Hubs (Unit 2). Coupled with 8s Loop + Single Mode, this is safe.
# 3. BASE: Includes all V24.1 features (AC-Charge sensors, 90% Leakage Buffer,
#    Safety Checks, etc.).
# CHANGELOG V26.0:
# 1. BIAS TUNING: Winter Bias set to 20W (Safety Import), Summer to 20W.
#    -> Prevents feed-in (Einspeisung) effectively.
# 2. TRAFFIC SAVER: 'State Machine' writes settings only every 5 mins (was 1m).
# 3. RELAXED LOOP: Control Loop slowed to 10s (was 8s) to relieve WiFi.
# 4. HYSTERESIS: Increased to 15W. Small load changes (LED lights) are ignored
#    to prevent 'ping-pong' commands.
# 5. BASE: Includes V25 "Self-Healing" (MQTT Memory Sync) & 10s Timeouts.
# CHANGELOG V27.0:
# 1. TRAFFIC CUT: Hysteresis increased to 20W.
#    -> Reduces Wi-Fi traffic by ~20% compared to 15W.
#    -> Prevents "congested timeouts" when big load changes occur.
# 2. SAFETY BIAS: Grid Bias fixed at 20W (Summer & Winter).
#    -> Ensures 0 export while maintaining a stable regulation baseline.
# 3. SYNTAX FIX: Updated templates to use proper is_number() function syntax.
# 4. LOGIC: Retains V26 fixes (10s Loop, 5min State Machine, MQTT Self-Healing).
# CHANGELOG V27.1:
# 1. PHANTOM CHARGE FIX: Increased Bypass Exit Hysteresis from 3% to 5%.
#    -> Prevents restart when battery voltage relaxes (e.g. 24% -> 28% jump).
#    -> New Start Threshold (Winter): 25% + 5% = 30%.
# 2. BASE: Based on V27.0 (20W Bias / 20W Hysteresis / Traffic Opt).
# V27.3: PHANTOM CHARGE FIX (Hardware Buffer):
#        - Decoupled Software-Limit from Hardware-Limit.
#        - Winter: Soft-Stop 20% / Hard-Limit 10% -> Prevents re-charging at 19%.
# V27.4: SUMMER SAFETY CORRIDOR:
#        - Summer: Soft-Stop 8% / Hard-Limit 6% -> Prevents re-charging at 7%.
#        - Keeps 1% distance to the critical 5% Firmware-Panic-Line.
# CHANGELOG V27.5 (Traffic Optimization):
# 1. SMART WRITES: State Machine now checks current device settings via MQTT
#    before sending a command.
#    -> If Target == Current, NO command is sent.
#    -> Reduces "Setting-Spam" by ~95%, preventing Timeouts.
# 2. SENSOR UPDATE: Added MQTT sensors for 'chargeMaxLimit' and 'minSoc'
#    to enable the comparison logic.
# CHANGELOG V27.8 (Precision Tuning):
# 1. SUMMER TARGET: Emergency Charge stops at 9% (below Software Stop 10%).
#    -> Prevents immediate re-discharge loop.
# 2. BYPASS INTEGRATION: Schonmodus logic confirmed (10-15% range in Summer).
# 3. SAFETY: Soft-Start Limit (<12%) ensures we never hit 800W near the bottom.
# CHANGELOG V27.9 (Notifications & Fixes):
# 1. FORECAST FIX: Auto-Emergency Manager now uses 'energy_production_today'
#    at 02:00 AM (feedback implementation).
# 2. NOTIFICATIONS: Added Telegram alerts for:
#    - Individual Unit Offline (5min)
#    - Emergency Charge Start/Stop
#    - Calibration Start/Stop
#    - Temp Warning (>45°C) and Critical (>55°C)
#    - Low Temp (<0°C)
# 3. HEAT PROTECTION: Lowered threshold to 45°C for earlier bypass action.
# 4. GLOBAL LIMIT: Re-confirmed that Output is clamped at 800W even in Bypass.
# CHANGELOG V27.13 (Calibration Perfection):
# 1. 24/7 EMERGENCY: Removed time restriction. Low SoC protection now active
#    all day (essential for battery health), but guarded by Forecast check.
# 2. CALIBRATION LOGIC SPLIT:
#    - Emergency Charge: Limited to 300W (Safety).
#    - Calibration Charge: Uses dynamic limits (800W -> 200W -> 100W) to
#      ensure timely completion AND proper cell balancing at the top.
# 3. MANAGER: Confirmed auto-start (14 days), auto-stop (100%), and notifications.
# CHANGELOG V27.17 (Consolidation & Wording):
# 1. RESTORED: Energy Sensors block (Section 4) confirmed present.
# 2. RESTORED: Global Settings reset in Season Manager confirmed present.
# 3. RENAMED: Notification IDs and Titles are now generic ("Netzdaten fehlen"
#    instead of "Shelly Fail") to avoid confusion.
# 4. LOGIC: Includes Split-Calibration (U1/U2) and Hybrid Triggers (Time/Voltage).
# CHANGELOG V27.21 (Safety Override & Fixes):
# 1. CRITICAL LOGIC FIX ("Safety Override"):
#    - Capacity limits (SoC/Temp/Bypass) are now calculated BEFORE the
#      hysteresis condition check.
#    - If current output > allowed capacity, the loop triggers IMMEDIATELY,
#      ignoring the hysteresis.
#    - Prevents battery draining below 20% if grid load is constant.
# 2. INSTANT TRIGGER: Added Bypass Switches to Control Loop triggers for
#    immediate reaction when modes change.
# 3. CONFIG: Confirmed Winter Emergency Start at 15%.
# 4. RETAINED: All V27.20 features (Energy Sensors, 55°C Alarm, etc.).
# CHANGELOG V27.24 (Ghost Load Protection):
# 1. CRITICAL SAFETY FIX: "Offline Memory Trust".
#    - Previously: If a unit went offline, its output was calculated as 0W.
#      This caused the other unit to ramp up, violating the 800W total limit.
#    - NOW: If a unit is offline, the script assumes it is STUCK at its last
#      known value. It includes this "Ghost Load" in the math.
#    - Result: If Unit 2 drops offline at 400W, Unit 1 will NOT ramp up.
#      Total Output remains safe (<= 800W).
# 2. BUGFIXES RETAINED: Variable fix (Weekly Report), 15% Winter Start.
# CHANGELOG V27.25 (Robustness & Cleanup):
# 1. SENSORS: Added 'is_number' check to Template Sensors to prevent log errors
#    during Home Assistant startup.
# 2. SENSORS: Added smart scaling to Cell Voltage sensors. Automatically converts
#    mV to V if values > 20 are detected.
# 3. PERF: Reduced REST timeout to 5s (was 10s) to prevent system lag when
#    Unit 2 has WiFi issues.
# 4. LOGIC: Retained Ghost Load Protection & Safety Override from V27.24.
# CHANGELOG V27.26 (Logic Fix):
# 1. LOGIC FIX: Increased Winter Emergency Stop SoC from 20% to 25%.
#    - Reason: Prevents oscillation at the 20% discharge limit.
#    - Now: Battery charges to 25%, giving a 5% buffer before discharge
#      limit (20%) is hit again.
# 2. RETAINED: All V27.25 features (Safety Override, 5s Timeout, Smart Sensors).
# CHANGELOG V27.27 (User Requests):
# 1. SENSORS: Kept original sensor names (no "_internal"), but added "is_number"
#    logic to prevent log errors during startup.
# 2. FORECAST: Switched Emergency Manager to use 'energy_production_today_remaining'
#    for smarter decisions (only charge grid if no sun is coming).
# 3. SAFETY: Added "Hard Stop" (0W) when Auto Mode is turned OFF.
# 4. LOGIC: Confirmed Winter settings:
#    - Emerg Stop 25% / Bypass Exit 30% -> Battery holds charge at 25% (Good).
# CHANGELOG V27.28 (Final Polish):
# 1. PERFORMANCE: Calibration Mode now allows up to 800W charging power
#    (if Temp > 10°C and SoC < 90%), removing the 300W "soft limit".
# 2. LOGIC: Emergency Manager now uses 'energy_production_today_remaining'
#    to decide if grid charging is necessary (Save money if sun is coming).
# 3. ROBUSTNESS: Added "is_number" checks to all sensors to prevent log errors,
#    BUT kept original sensor names to preserve Dashboard/History.
# 4. SAFETY: "Auto Mode OFF" triggers immediate 0W hard stop.
# CHANGELOG V27.29 (Future-Proofing):
# 1. SYSTEM SAFETY: Added 'object_id' to critical MQTT sensors. This forces
#    Home Assistant to use the exact Entity IDs required by the script
#    (e.g., 'sensor.solarflow_1_solar_input') regardless of the display name.
#    Prevents "Unknown Entity" errors after backups/reinstalls.
# 2. RETAINED: All V27.28 features (800W Calibration, Forecast Logic, Hard Stop).
# CHANGELOG V27.30 (Stability & Logic Polish):
# 1. SENSORS: Added 'availability' template to battery sensors. This is the
#    cleanest way to prevent "Unknown" errors in logs without suppressing data.
# 2. LOGIC FIX: Control Loop now actively regulates even when Capacity is 0W
#    (e.g., during Bypass). Previously, it would "pause" and hold the last value.
#    Now it correctly forces 0W output.
# 3. NETWORK: Increased MQTT 'expire_after' to 120s (was 60s). This prevents
#    sensors from flickering "unavailable" during short WiFi hiccups, without
#    slowing down the actual control loop.
# 4. CONFIG: Kept 'min_soc: 50' as per user confirmation.
# CHANGELOG V27.31 (Stability & Spillover Update):
# 1. NETWORK: Switched Control Loop from 'parallel' to 'sequence' with 500ms delay.
#    Drastically reduces WiFi congestion and ESP timeouts on the Zendure units.
# 2. LOGIC: Added "Solar Spillover". If a unit is in Bypass (Full), it forces
#    a minimum output of 350W (limited by available solar) to feed the grid
#    instead of wasting energy, regardless of house consumption.
# 3. SAFETY: Removed Forecast condition from Emergency Charge. Now triggers
#    ALWAYS if SoC < 15% to protect hardware from deep discharge.
# 4. MATH: Added explicit "max(0)" clamp to output calculation to prevent
#    negative values during edge-cases (e.g. one unit offline + low load).
# 5. CODE: Modernized timestamp checks (as_timestamp) and cleaned up imbalance math.
# CHANGELOG V27.32 (Final Stability & Logic Fixes):
# 1. LOGIC FIX: "Solar Spillover" (350W min output) now only triggers if
#    SoC >= 98%. Previously triggered on Bypass (which includes low battery),
#    potentially draining the battery further.
# 2. DATA INTEGRITY: "Total" sensors now check if units are ONLINE. If offline,
#    values default to 0. This prevents "Phantom Energy" accumulation in
#    Riemann Sum/Integration sensors during connection drops.
# 3. ANTI-SPAM: Emergency & Calibration notifications now only fire once upon
#    activation, not repeatedly on every check cycle.
# 4. FUTURE PROOF: Replaced deprecated 'object_id' with 'default_entity_id'
#    in MQTT config to align with Home Assistant 2026 standards.
# CHANGELOG V27.35 (Final Polish):
# 1. LOGIC FIX: "Solar Spillover" (350W min output) is now safer. It only triggers
#    if SoC >= 98% AND Solar Input > 400W. This prevents draining the battery
#    into the grid at night or during low-light conditions.
# 2. SENSOR AVAILABILITY: Battery Level and Imbalance sensors now check the
#    'Status Raw' watchdog. If the unit is offline, sensors report 'unavailable'
#    instead of stale values.
# 3. NETWORK: Increased Watchdog expiry to 300s (5min) to prevent false offline
#    flapping. Control loop remains sequential (500ms delay) for stability.
# 4. NOTIFICATIONS: Telegram messages now use dynamic templates (showing actual
#    thresholds) and only fire once per activation (Anti-Spam).
# 5. CLEANUP: Removed all legacy code, unused helpers, and applied 'default_entity_id'
#    globally for future-proofing.
# CHANGELOG V27.37 (2-Stage Spillover):
# 1. LOGIC TUNING: Implemented a 2-stage Spillover logic for full batteries (>98%).
#    - Stage 1: Solar > 300W -> Output 250W (500W Total). Starts early, calms regulation.
#    - Stage 2: Solar > 400W -> Output 350W (700W Total). Captures peak power.
# 2. RETAINED: All V27.35 features (Sequential Control, Full ID Locking,
#    Phantom Energy Protection, Anti-Spam Notifications).
# CHANGELOG V27.38 (Safety & Stability Polish):
# 1. HARD LIMIT: Added a mathematical safety clamp at the end of the control loop.
#    If (Final_1 + Final_2) > 800W, both outputs are scaled down proportionally.
#    This guarantees legal grid compliance regardless of spillover settings.
# 2. PERFORMANCE: Reduced REST command timeout from 5s to 2s. This prevents the
#    10s control loop from overlapping/lagging if units go offline.
# 3. ROBUSTNESS: Improved Cell Imbalance sensor (clamps negative values, better
#    availability check) and Weekly Report (handles missing data correctly).
# 4. SYNTAX: Standardized 'delay' to use 'milliseconds: 500' instead of strings.
# CHANGELOG V27.39 (Robustness & Error Handling):
# 1. SMART REST: The script now checks the HTTP response code. 'last_sent' memory
#    is ONLY updated if the Zendure unit responds with HTTP 200 OK. Prevents
#    "ghost states" where the script thinks it regulated, but the call failed.
# 2. TIMING: REST Timeout set to 4s. This allows enough time for WiFi latency
#    but guarantees the total runtime (4+0.5+4 = 8.5s) fits into the 10s loop.
# 3. CALIBRATION FIX: Switched from 'choose' to sequential 'if' blocks. Now
#    both units can enter/exit calibration in the same run if needed.
# 4. STARTUP SAFETY: Health Monitor triggers converted to templates to handle
#    "unknown" entities during Home Assistant startup gracefully.
# 5. TUNING: Watchdog expiry set to 120s (faster offline detection). Added
#    'max_sub_interval' to energy sensors for better precision.
# CHANGELOG V27.40 (Logic Isolation & Hardening):
# 1. STATE MACHINE FIX: Separated the "Reset to 0W" logic. Unit 1 completing
#    calibration no longer forces Unit 2 to 0W. Each unit checks its own flags.
# 2. DYNAMIC SCALING: The final safety clamp now scales output to the configured
#    'max_output' slider value (e.g. 600W) instead of hardcoded 800W.
# 3. ID HARDENING: Added 'default_entity_id' to Watchdog sensors to prevent ID
#    shifts. Template sensors now return 'unavailable' instead of '0' on error.
# 4. ROBUSTNESS: Memory Sync Automation checks for valid numbers before writing.
#    Retained V27.39 features (Smart REST Check, 4s Timeout, Seq. Calibration).
# CHANGELOG V27.41 (True Dual Mode & Smart Reset):
# 1. TRUE DUAL MODE: Removed calibration checks from Control Loop conditions.
#    The loop now calculates for both, but forces 0 capacity for calibrating units.
#    Commands are only sent to non-calibrating units.
# 2. SMART DATE RESET: 'last_full_charge' is now updated whenever battery hits
#    >99% for 5 mins (Solar or Manual), preventing unnecessary scheduled calibs.
# 3. STATE MACHINE FIX: "Reset to 0W" triggers are now entity-specific.
#    Unit 1 finishing calibration will NOT reset Unit 2.
# 4. RETAINED: All hardening from V27.40 (Dynamic Scaling, Smart REST 200 OK,
#    4s Timeout, Robust Sensors).
# CHANGELOG V28.0 (Logic Hardening & Bugfixes):
# 1. STATE MACHINE ISOLATION: The "Reset to 0W" logic now strictly checks the
#    trigger.entity_id. Unit 1 ending calibration will NEVER reset Unit 2.
# 2. SENSOR STABILITY: 'SolarFlow System Battery Level' now uses 'availability'
#    templating to prevent ValueError logs when data is missing.
# 3. MEMORY PROTECTION: Added 'is_number()' check to memory sync automation to
#    prevent learning '0' during brief sensor unavailability.
# 4. CODE CLEANUP: Anti-Drift Watchdog refactored to use 'choose' instead of
#    templated target IDs for better stability.
# 5. RETAINED: Smart Date Reset (on full charge), Dynamic Scaling, Smart REST.
# (No writeFlash parameter included).
# CHANGELOG V29.0 (Intelligent Protection & Hardening):
# 1. DYNAMIC HYSTERESIS: When in Bypass Mode (Low Battery), the 'min_change'
#    threshold increases from 10W to 50W. This drastically reduces flash writes
#    during cloudy days when the battery is idle/protecting.
# 2. STATE MACHINE ISOLATION: The "Reset to 0W" logic now strictly checks the
#    trigger.entity_id. Unit 1 ending calibration will NEVER reset Unit 2.
# 3. SMART DATE RESET: 'last_full_charge' is updated whenever battery hits 99%,
#    regardless of calibration mode.
# 4. SENSOR STABILITY: 'SolarFlow System Battery Level' uses 'availability'
#    templating to prevent ValueError logs.
# 5. MEMORY PROTECTION: 'is_number()' check added to memory sync automation.
# CHANGELOG V30.0:
# 1. EMERGENCY STOP: Added solar trigger (>200W) to stop grid charging.
# 2. MIN_SOC FIX: Reduced hardware min_soc from 50 to 5.
# 3. HYBRID LOGIC: Dynamic switching between "Zen Mode" and "Sniper Mode".
# CHANGES V32.1:
# - Loop-Time: 5 Seconds (Realtime-Response).
# - Protocol: Pure MQTT (No HTTP/Rest).
# - Logic: Removed "Zen-Mode" delay (Bypass follows Solar instantly).
# - Settings: Tighter Hysteresis (10W) & Grid Bias (10W) in Season Manager.
# CRITICAL FIXES V33:
# - Fix: AC-Mode switch-back logic now uses internal sentinel (not sensor value).
# - Fix: Forces OutputLimit to 0 when entering Charge/Calibration mode.
# - Fix: SmartMode is re-applied when device comes back online.
# - Fix: Anti-Drift ignores periods where device is in Charge Mode (-2).
# TUNING V33:
# - Speed: Max Step Up increased to 800W (Instant Response).
# - Logic: Automation mode changed to 'restart' for realtime handling.
# - MQTT: Added QoS: 1 for reliable command delivery.
# CHANGES V33.1:
# - REMOVED: Artificial Ramp-Up logic (Direct Target Calculation).
# - REMOVED: Delays between MQTT commands (Parallel Execution).
# - FIXED: AC-Mode switch-back using internal sentinel (-2).
# - FIXED: OutputLimit forced to 0 during Charge/Calib modes.
# - TUNED: Automation mode 'restart' for instant response.
# MAJOR FIXES V34:
# - CALIBRATION: Timer resets on ANY 100% charge (solar or forced).
# - LOOP: Changed to 'mode: single' to prevent race conditions during load spikes.
# - LOGIC: Hardened Sentinel (-2) clearing when switching back to Normal Mode.
# - SAFETY: Auto-Emergency trigger protected against 'unavailable' sensors.
# - BOOT: State Machine now checks status on 'homeassistant start'.
# - CLEANUP: Removed deprecated 'default_entity_id', increased Watchdog to 300s.
# CHANGES V36.0:
# - LOGIC: Dynamic Hysteresis (5W Sport / 20W Zen-Mode) to save hardware.
# - SAFETY: Ghost Load Protection (Offline units reduce available global power).
# - SAFETY: Emergency Charge now requires 10 min stable low-solar condition.
# - SAFETY: Voltage Sag Calibration only triggers between 10:00 - 15:00.
# - STABILITY: Restored 'default_entity_id' for critical sensors (Reinstall-safe).
# - SYNTAX: Converted all 'if' conditions to valid list format.
#
# CHANGELOG V27.40 (Logic Isolation & Hardening):
# 1. STATE MACHINE FIX: Separated the "Reset to 0W" logic. Unit 1 completing
#    calibration no longer forces Unit 2 to 0W. Each unit checks its own flags.
# 2. DYNAMIC SCALING: The final safety clamp now scales output to the configured
#    'max_output' slider value (e.g. 600W) instead of hardcoded 800W.
# 3. ID HARDENING: Added 'default_entity_id' to Watchdog sensors to prevent ID
#    shifts. Template sensors now return 'unavailable' instead of '0' on error.
# 4. ROBUSTNESS: Memory Sync Automation checks for valid numbers before writing.
#    Retained V27.39 features (Smart REST Check, 4s Timeout, Seq. Calibration).
#
# CHANGELOG V27.41 (True Dual Mode & Smart Reset):
# 1. TRUE DUAL MODE: Removed calibration checks from Control Loop conditions.
#    The loop now calculates for both, but forces 0 capacity for calibrating units.
#    Commands are only sent to non-calibrating units.
# 2. SMART DATE RESET: 'last_full_charge' is now updated whenever battery hits
#    >99% for 5 mins (Solar or Manual), preventing unnecessary scheduled calibs.
# 3. STATE MACHINE FIX: "Reset to 0W" triggers are now entity-specific.
#    Unit 1 finishing calibration will NOT reset Unit 2.
# 4. RETAINED: All hardening from V27.40 (Dynamic Scaling, Smart REST 200 OK,
#    4s Timeout, Robust Sensors).
#
# CHANGELOG V28.0 (Logic Hardening & Bugfixes):
# 1. STATE MACHINE ISOLATION: The "Reset to 0W" logic now strictly checks the
#    trigger.entity_id. Unit 1 ending calibration will NEVER reset Unit 2.
# 2. SENSOR STABILITY: 'SolarFlow System Battery Level' now uses 'availability'
#    templating to prevent ValueError logs when data is missing.
# 3. MEMORY PROTECTION: Added 'is_number()' check to memory sync automation to
#    prevent learning '0' during brief sensor unavailability.
# 4. CODE CLEANUP: Anti-Drift Watchdog refactored to use 'choose' instead of
#    templated target IDs for better stability.
# 5. RETAINED: Smart Date Reset (on full charge), Dynamic Scaling, Smart REST.
#    (No writeFlash parameter included).
#
# CHANGELOG V29.0 (Intelligent Protection & Hardening):
# 1. DYNAMIC HYSTERESIS: When in Bypass Mode (Low Battery), the 'min_change'
#    threshold increases from 10W to 50W. This drastically reduces flash writes
#    during cloudy days when the battery is idle/protecting.
# 2. STATE MACHINE ISOLATION: The "Reset to 0W" logic now strictly checks the
#    trigger.entity_id. Unit 1 ending calibration will NEVER reset Unit 2.
# 3. SMART DATE RESET: 'last_full_charge' is updated whenever battery hits 99%,
#    regardless of calibration mode.
# 4. SENSOR STABILITY: 'SolarFlow System Battery Level' uses 'availability'
#    templating to prevent ValueError logs.
# 5. MEMORY PROTECTION: 'is_number()' check added to memory sync automation.
#
# CHANGELOG V30.0:
# 1. EMERGENCY STOP: Added solar trigger (>200W) to stop grid charging.
# 2. MIN_SOC FIX: Reduced hardware min_soc from 50 to 5.
# 3. HYBRID LOGIC: Dynamic switching between "Zen Mode" and "Sniper Mode".
#
# CHANGES V32.1:
# - Loop-Time: 5 Seconds (Realtime-Response).
# - Protocol: Pure MQTT (No HTTP/Rest).
# - Logic: Removed "Zen-Mode" delay (Bypass follows Solar instantly).
# - Settings: Tighter Hysteresis (10W) & Grid Bias (10W) in Season Manager.
#
# CRITICAL FIXES V33:
# - Fix: AC-Mode switch-back logic now uses internal sentinel (not sensor value).
# - Fix: Forces OutputLimit to 0 when entering Charge/Calibration mode.
# - Fix: SmartMode is re-applied when device comes back online.
# - Fix: Anti-Drift ignores periods where device is in Charge Mode (-2).
#
# TUNING V33:
# - Speed: Max Step Up increased to 800W (Instant Response).
# - Logic: Automation mode changed to 'restart' for realtime handling.
# - MQTT: Added QoS: 1 for reliable command delivery.
#
# CHANGES V33.1:
# - REMOVED: Artificial Ramp-Up logic (Direct Target Calculation).
# - REMOVED: Delays between MQTT commands (Parallel Execution).
# - FIXED: AC-Mode switch-back using internal sentinel (-2).
# - FIXED: OutputLimit forced to 0 during Charge/Calib modes.
# - TUNED: Automation mode 'restart' for instant response.
#
# MAJOR FIXES V34:
# - CALIBRATION: Timer resets on ANY 100% charge (solar or forced).
# - LOOP: Changed to 'mode: single' to prevent race conditions during load spikes.
# - LOGIC: Hardened Sentinel (-2) clearing when switching back to Normal Mode.
# - SAFETY: Auto-Emergency trigger protected against 'unavailable' sensors.
# - BOOT: State Machine now checks status on 'homeassistant start'.
# - CLEANUP: Removed deprecated 'default_entity_id', increased Watchdog to 300s.
#
# CHANGES V36.0:
# - LOGIC: Dynamic Hysteresis (5W Sport / 20W Zen-Mode) to save hardware.
# - SAFETY: Ghost Load Protection (Offline units reduce available global power).
# - SAFETY: Emergency Charge now requires 10 min stable low-solar condition.
# - SAFETY: Voltage Sag Calibration only triggers between 10:00 - 15:00.
# - STABILITY: Restored 'default_entity_id' for critical sensors (Reinstall-safe).
# - SYNTAX: Converted all 'if' conditions to valid list format.
#
# CHANGES V37.0:
# - WATCHDOG: Sensors now report REAL payload (e.g. "FAULT") instead of fake "OK".
# - STABILITY: Anti-Drift Automation set to 'queued' to prevent overlapping writes.
# - LOGIC: Emergency Stop trigger (>200W Solar) increased to 5 min delay.
# - SEASON: Calibration interval is now dynamic (14d Summer / 30d Winter).
# - BASE: Based on V36.1 (Bulletproof ID-Locking, Ghost Protection, List-Syntax).
#
## CHANGES V38.0:
# - MATH FIX: 'target_clamped' now correctly references 'global_max' to avoid
#   double-subtraction of ghost loads.
# - SCALING FIX: Safety scaling now only throttles ONLINE units, respecting
#   that offline units cannot be controlled (Ghost Load preserved).
# - SAFETY: 'Auto-Off' only resets internal memory to 0 if the unit is actually
#   ONLINE. Prevents losing track of potential output from offline units.
# - LOGIC: Control Loop now triggers on Bypass ON and OFF (immediate reaction).
# - BASE: Based on V37.1 (Fixed 14d Calib, Real Watchdog, Queued Drift).
#
# CHANGES V39.0:
# - PROTOCOL FIX: Adapted to confirmed MQTT Explorer data:
#     -> acMode is 'select' (Payloads: "Input mode" / "Output mode").
#     -> smartMode is 'switch' (Payload: "ON").
# - MATH FIX: 'target_clamped' references 'global_max' (Ghost Load Logic Fix).
# - SCALING: Scales only ACTIVE units to fit remaining capacity.
# - LOGIC: 
#     -> Spillover disabled if unit is busy/calibrating.
#     -> 'min_change' slider used for Sport (x1) and Zen (x4).
#     -> Emergency Stop trigger added (2 min stable).
#     -> Auto-Off memory reset protected (only if online).
# - SYNTAX: Modernized to 'triggers:' list format.
#
# CHANGES V40.0:
# - SAFETY GATE: Loop now triggers IMMEDIATELY if Total Output > Global Max,
#   ignoring hysteresis. Prevents illegal output during ghost-load scenarios.
# - MATH PERFECTION: Clean separation of 'target_total' vs 'target_online'.
#   Ghost loads are subtracted from the target, ensuring online units only
#   fill the remaining gap up to global_max.
# - ROBUSTNESS: 
#     -> 's1_ok' now blacklists 'FAULT'/'ERROR' explicitly.
#     -> Watchdog timing tightened (120s expire + 3min trigger = 5min total).
#     -> Input Numbers now have explicit 'step' to satisfy HA 2026 checks.
#     -> Numeric payloads quoted (e.g., payload: "0").
# - LOGIC: Spillover disabled if unit is busy. Emergency Stop Trigger bound properly.
#
# CHANGES V41.0:
# - ANTI-SPAM: Loop only triggers on "Overload" if the unit can actually reduce
#   its output (base > final). Prevents endless "0W" commands during ghost loads.
# - SAFETY RECONNECT: Units coming online while Auto-Mode is OFF immediately
#   receive "Output: 0" and "Mode: Output". Prevents unmanaged discharge.
# - FULL RESET: Turning Auto-Mode OFF now clears all internal flags (Emergency,
#   Calib) and resets acMode to Output, ensuring a clean state.
# - EMERGENCY LOGIC: Stop condition now strictly bound to stable triggers
#   (5min Solar or Battery Full). Periodic checks cannot accidentally stop charge.
# - SYNTAX: Strict numeric casting |int(0) and list-based 'if' conditions.
#
# CHANGES V42.0:
# - EMERGENCY LOGIC: Stop condition changed to "System Minimum". Charging stops
#   only when ALL available units are above the threshold. Prevents early cut-off.
# - MEMORY GUARD: Startup-Sync Automation respects Sentinel (-2). It will NOT
#   overwrite internal memory if the unit is currently in Charge/Calib mode.
# - SAFETY RECONNECT: "Auto-Off" reconnect logic now explicitly resets internal
#   memory to 0, preventing ghost-load tracking from previous sessions.
# - CLEANUP: Removed 'state_class' and 'expire_after' from setting sensors
#   (OutputLimit, MinSoC) to keep database clean and prevent false availability.
# - BASE: Based on V41.0 (Bulletproof Anti-Spam & Protocol).
#
################################################################################

# ==============================================================================
# 1. KONFIGURATION (Input Helpers)
# ==============================================================================
input_boolean:
  zendure_auto_mode:
    name: "Zendure Automatik Aktiv"
    icon: mdi:robot
  
  zendure_emergency_charge:
    name: "Status: Not-Ladung läuft (System)"
    icon: mdi:battery-alert
  
  zendure_calib_mode_u1:
    name: "Status: Kalibrierung U1"
    icon: mdi:battery-sync
  zendure_calib_mode_u2:
    name: "Status: Kalibrierung U2"
    icon: mdi:battery-sync
  
  zendure_bypass_u1:
    name: "Intern: Bypass Latch U1"
    icon: mdi:lock-clock
  zendure_bypass_u2:
    name: "Intern: Bypass Latch U2"
    icon: mdi:lock-clock

input_datetime:
  zendure_last_full_charge_1:
    name: "Unit 1: Letzte 100%"
    has_date: true
    has_time: true
  zendure_last_full_charge_2:
    name: "Unit 2: Letzte 100%"
    has_date: true
    has_time: true

input_number:
  zendure_last_sent_1:
    name: "System: Letzter Wert Unit 1"
    min: -2
    max: 1200
    step: 1
    mode: box
  zendure_last_sent_2:
    name: "System: Letzter Wert Unit 2"
    min: -2
    max: 1200
    step: 1
    mode: box
  zendure_conf_max_output:
    name: "Zendure: Max. Einspeisung (Gesamt)"
    min: 0
    max: 800
    step: 10
    initial: 800
    unit_of_measurement: "W"
    mode: box
  zendure_conf_failsafe_watt:
    name: "Zendure: Failsafe Grundlast"
    min: 0
    max: 800
    step: 10
    initial: 130
    unit_of_measurement: "W"
  
  # Bias 10W (Standard)
  zendure_conf_grid_bias:
    name: "Zendure: Netz-Puffer (Bias)"
    min: -100
    max: 100
    step: 1
    initial: 10
    unit_of_measurement: "W"
  
  # Min Change Slider (Used as Base: 5W Sport / 20W Zen)
  zendure_conf_min_change:
    name: "Zendure: Min. Änderungsschritt"
    min: 1
    max: 50
    step: 1
    initial: 5
    unit_of_measurement: "W"
    
  # Hysteresis 10W (Standard)
  zendure_conf_hysteresis:
    name: "Zendure: Regel-Hysterese (Deadband)"
    min: 0
    max: 50
    step: 1
    initial: 10
    unit_of_measurement: "W"
    
  zendure_conf_soc_off:
    name: "SoC Limit: Not-Aus (Software)"
    min: 0
    max: 30
    step: 1
    initial: 20
    unit_of_measurement: "%"
  zendure_conf_soc_bypass:
    name: "SoC Limit: Schonmodus (Start)"
    min: 10
    max: 90
    step: 1
    initial: 25
    unit_of_measurement: "%"
  zendure_conf_soc_emerg_start:
    name: "SoC Limit: Start Not-Ladung"
    min: 0
    max: 50
    step: 1
    initial: 15
  zendure_conf_soc_emerg_stop:
    name: "SoC Limit: Stopp Not-Ladung"
    min: 0
    max: 90
    step: 1
    initial: 20
  zendure_conf_calib_days:
    name: "Kalibrierung: Intervall"
    min: 1
    max: 60
    step: 1
    initial: 14
    unit_of_measurement: "Tage"

# ==============================================================================
# 2. MQTT SENSOREN
# ==============================================================================
mqtt:
  sensor:
    # --- UNIT 1 ---
    - name: "SolarFlow 1 Solar Input Total"
      unique_id: solarflow_1_solar_input_mqtt
      default_entity_id: sensor.solarflow_1_solar_input
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/solarInputPower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 1 Grid Input Power"
      unique_id: solarflow_1_grid_input_mqtt
      default_entity_id: sensor.solarflow_1_grid_input_power
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/gridInputPower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 1 Battery Level Hub"
      unique_id: solarflow_1_battery_level_mqtt
      default_entity_id: sensor.solarflow_1_battery_level_hub
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/electricLevel"
      unit_of_measurement: "%"
      device_class: battery
      state_class: measurement

    - name: "SolarFlow 1 Output Power"
      unique_id: solarflow_1_output_power_mqtt
      default_entity_id: sensor.solarflow_1_output_power
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/outputHomePower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 1 Output Limit"
      unique_id: solarflow_1_output_limit_mqtt
      default_entity_id: sensor.solarflow_1_output_limit
      state_topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit"
      unit_of_measurement: "W"
      # V42: Removed state_class/expire_after for settings (cleaner DB)

    # Feedback Sensors
    - name: "SolarFlow 1 Setting MinSoC"
      unique_id: solarflow_1_setting_minsoc
      default_entity_id: sensor.solarflow_1_setting_minsoc
      state_topic: "Zendure/number/HUB1_SERIAL_NUMBER/minSoc"
      unit_of_measurement: "%"
    
    - name: "SolarFlow 1 Setting ChargeLimit"
      unique_id: solarflow_1_setting_chargelimit
      default_entity_id: sensor.solarflow_1_setting_chargelimit
      state_topic: "Zendure/number/HUB1_SERIAL_NUMBER/chargeMaxLimit"
      unit_of_measurement: "W"

    - name: "SolarFlow 1 Temp"
      unique_id: solarflow_1_temp_mqtt
      default_entity_id: sensor.solarflow_1_temp
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/hyperTmp"
      unit_of_measurement: "°C"
      state_class: measurement
      value_template: >
        {% set v = value | float(0) %}
        {% if v > 1000 %} {{ ((v - 2731) / 10) | round(1) }}
        {% else %} {{ v }} {% endif %}

    - name: "SolarFlow 1 Battery Max Temp"
      unique_id: solarflow_1_batt_max_temp
      default_entity_id: sensor.solarflow_1_batt_max_temp
      state_topic: "Zendure/sensor/BAT1_SERIAL_NUMBER/maxTemp"
      unit_of_measurement: "°C"
      state_class: measurement
      value_template: >
        {% set v = value | float(0) %}
        {% if v > 1000 %} {{ ((v - 2731) / 10) | round(1) }}
        {% else %} {{ v }} {% endif %}

    - name: "SolarFlow 1 Cell Max Vol"
      unique_id: solarflow_1_cell_max_vol
      default_entity_id: sensor.solarflow_1_cell_max_vol
      state_topic: "Zendure/sensor/BAT1_SERIAL_NUMBER/maxVol"
      unit_of_measurement: "V"
      state_class: measurement
      value_template: >
        {% set v = value | float(none) %}
        {% if v is none %} {{ '' }}
        {% elif v > 20 %} {{ (v / 100) | round(3) }}
        {% else %} {{ v | round(3) }}
        {% endif %}

    - name: "SolarFlow 1 Cell Min Vol"
      unique_id: solarflow_1_cell_min_vol
      default_entity_id: sensor.solarflow_1_cell_min_vol
      state_topic: "Zendure/sensor/BAT1_SERIAL_NUMBER/minVol"
      unit_of_measurement: "V"
      state_class: measurement
      value_template: >
        {% set v = value | float(none) %}
        {% if v is none %} {{ '' }}
        {% elif v > 20 %} {{ (v / 100) | round(3) }}
        {% else %} {{ v | round(3) }}
        {% endif %}
      

    # --- UNIT 2 ---
    - name: "SolarFlow 2 Solar Input Total"
      unique_id: solarflow_2_solar_input_mqtt
      default_entity_id: sensor.solarflow_2_solar_input
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/solarInputPower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 2 Grid Input Power"
      unique_id: solarflow_2_grid_input_mqtt
      default_entity_id: sensor.solarflow_2_grid_input_power
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/gridInputPower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 2 Battery Level Hub"
      unique_id: solarflow_2_battery_level_mqtt
      default_entity_id: sensor.solarflow_2_battery_level_hub
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/electricLevel"
      unit_of_measurement: "%"
      device_class: battery
      state_class: measurement

    - name: "SolarFlow 2 Output Power"
      unique_id: solarflow_2_output_power_mqtt
      default_entity_id: sensor.solarflow_2_output_power
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/outputHomePower"
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement

    - name: "SolarFlow 2 Output Limit"
      unique_id: solarflow_2_output_limit_mqtt
      default_entity_id: sensor.solarflow_2_output_limit
      state_topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit"
      unit_of_measurement: "W"
      # V42: Removed state_class/expire_after

    # Feedback Sensors
    - name: "SolarFlow 2 Setting MinSoC"
      unique_id: solarflow_2_setting_minsoc
      default_entity_id: sensor.solarflow_2_setting_minsoc
      state_topic: "Zendure/number/HUB2_SERIAL_NUMBER/minSoc"
      unit_of_measurement: "%"
    
    - name: "SolarFlow 2 Setting ChargeLimit"
      unique_id: solarflow_2_setting_chargelimit
      default_entity_id: sensor.solarflow_2_setting_chargelimit
      state_topic: "Zendure/number/HUB2_SERIAL_NUMBER/chargeMaxLimit"
      unit_of_measurement: "W"

    - name: "SolarFlow 2 Temp"
      unique_id: solarflow_2_temp_mqtt
      default_entity_id: sensor.solarflow_2_temp
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/hyperTmp"
      unit_of_measurement: "°C"
      state_class: measurement
      value_template: >
        {% set v = value | float(0) %}
        {% if v > 1000 %} {{ ((v - 2731) / 10) | round(1) }}
        {% else %} {{ v }} {% endif %}

    - name: "SolarFlow 2 Battery Max Temp"
      unique_id: solarflow_2_batt_max_temp
      default_entity_id: sensor.solarflow_2_batt_max_temp
      state_topic: "Zendure/sensor/BAT2_SERIAL_NUMBER/maxTemp"
      unit_of_measurement: "°C"
      state_class: measurement
      value_template: >
        {% set v = value | float(0) %}
        {% if v > 1000 %} {{ ((v - 2731) / 10) | round(1) }}
        {% else %} {{ v }} {% endif %}

    - name: "SolarFlow 2 Cell Max Vol"
      unique_id: solarflow_2_cell_max_vol
      default_entity_id: sensor.solarflow_2_cell_max_vol
      state_topic: "Zendure/sensor/BAT2_SERIAL_NUMBER/maxVol"
      unit_of_measurement: "V"
      state_class: measurement
      value_template: >
        {% set v = value | float(none) %}
        {% if v is none %} {{ '' }}
        {% elif v > 20 %} {{ (v / 100) | round(3) }}
        {% else %} {{ v | round(3) }}
        {% endif %}

    - name: "SolarFlow 2 Cell Min Vol"
      unique_id: solarflow_2_cell_min_vol
      default_entity_id: sensor.solarflow_2_cell_min_vol
      state_topic: "Zendure/sensor/BAT2_SERIAL_NUMBER/minVol"
      unit_of_measurement: "V"
      state_class: measurement
      value_template: >
        {% set v = value | float(none) %}
        {% if v is none %} {{ '' }}
        {% elif v > 20 %} {{ (v / 100) | round(3) }}
        {% else %} {{ v | round(3) }}
        {% endif %}

    # --- WATCHDOGS (120s Expiry) ---
    - name: "SolarFlow 1 Status Raw"
      unique_id: solarflow_1_status_mqtt
      default_entity_id: sensor.solarflow_1_status_raw
      state_topic: "Zendure/sensor/HUB1_SERIAL_NUMBER/packState"
      value_template: "{{ value }}"
      expire_after: 120

    - name: "SolarFlow 2 Status Raw"
      unique_id: solarflow_2_status_mqtt
      default_entity_id: sensor.solarflow_2_status_raw
      state_topic: "Zendure/sensor/HUB2_SERIAL_NUMBER/packState"
      value_template: "{{ value }}"
      expire_after: 120

# ==============================================================================
# 3. HELPER SENSOREN
# ==============================================================================
template:
  - sensor:
      - name: "SolarFlow 1 Battery Level"
        unique_id: solarflow_1_battery_level
        default_entity_id: sensor.solarflow_1_battery_level
        device_class: battery
        state_class: measurement
        unit_of_measurement: "%"
        availability: >
          {{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] 
             and is_number(states('sensor.solarflow_1_battery_level_hub')) }}
        state: >
          {{ states('sensor.solarflow_1_battery_level_hub') | int(0) }}
        
      - name: "SolarFlow 2 Battery Level"
        unique_id: solarflow_2_battery_level
        default_entity_id: sensor.solarflow_2_battery_level
        device_class: battery
        state_class: measurement
        unit_of_measurement: "%"
        availability: >
          {{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] 
             and is_number(states('sensor.solarflow_2_battery_level_hub')) }}
        state: >
          {{ states('sensor.solarflow_2_battery_level_hub') | int(0) }}

      - name: "SolarFlow Total Solar Input"
        unique_id: solarflow_total_solar_input
        default_entity_id: sensor.solarflow_total_solar_input
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >
          {% set s1_ok = states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s2_ok = states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s1 = states('sensor.solarflow_1_solar_input')|float(0) if s1_ok else 0 %}
          {% set s2 = states('sensor.solarflow_2_solar_input')|float(0) if s2_ok else 0 %}
          {{ (s1 + s2) | int }}

      - name: "SolarFlow Total Grid Input"
        unique_id: solarflow_total_grid_input
        default_entity_id: sensor.solarflow_total_grid_input
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >
          {% set s1_ok = states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s2_ok = states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s1 = states('sensor.solarflow_1_grid_input_power')|float(0) if s1_ok else 0 %}
          {% set s2 = states('sensor.solarflow_2_grid_input_power')|float(0) if s2_ok else 0 %}
          {{ (s1 + s2) | int }}

      - name: "SolarFlow System Total Output"
        unique_id: solarflow_system_total_output
        default_entity_id: sensor.solarflow_system_total_output
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >
          {% set s1_ok = states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s2_ok = states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] %}
          {% set s1 = states('sensor.solarflow_1_output_power')|float(0) if s1_ok else 0 %}
          {% set s2 = states('sensor.solarflow_2_output_power')|float(0) if s2_ok else 0 %}
          {{ (s1 + s2) | int }}

      - name: "SolarFlow System Battery Level"
        unique_id: solarflow_system_battery_level
        default_entity_id: sensor.solarflow_system_battery_level
        unit_of_measurement: "%"
        device_class: battery
        state_class: measurement
        availability: >
          {% set s1 = states('sensor.solarflow_1_battery_level') | float(-1) %}
          {% set s2 = states('sensor.solarflow_2_battery_level') | float(-1) %}
          {{ s1 >= 0 or s2 >= 0 }}
        state: >
          {% set s1 = states('sensor.solarflow_1_battery_level') | float(-1) %}
          {% set s2 = states('sensor.solarflow_2_battery_level') | float(-1) %}
          {% set ns = namespace(sum=0, count=0) %}
          {% if s1 >= 0 %}{% set ns.sum = ns.sum + s1 %}{% set ns.count = ns.count + 1 %}{% endif %}
          {% if s2 >= 0 %}{% set ns.sum = ns.sum + s2 %}{% set ns.count = ns.count + 1 %}{% endif %}
          {{ (ns.sum / ns.count) | round(0) if ns.count > 0 else 0 }}

      - name: "SolarFlow 1 Cell Imbalance"
        unique_id: solarflow_1_cell_imbalance
        default_entity_id: sensor.solarflow_1_cell_imbalance
        unit_of_measurement: "V"
        state_class: measurement
        availability: >
          {{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] 
             and is_number(states('sensor.solarflow_1_cell_min_vol')) 
             and is_number(states('sensor.solarflow_1_cell_max_vol')) }}
        state: >
          {% set min_v = states('sensor.solarflow_1_cell_min_vol') | float(0) %}
          {% set max_v = states('sensor.solarflow_1_cell_max_vol') | float(0) %}
          {{ [ (max_v - min_v) | round(3), 0 ] | max }}

      - name: "SolarFlow 2 Cell Imbalance"
        unique_id: solarflow_2_cell_imbalance
        default_entity_id: sensor.solarflow_2_cell_imbalance
        unit_of_measurement: "V"
        state_class: measurement
        availability: >
          {{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] 
             and is_number(states('sensor.solarflow_2_cell_min_vol')) 
             and is_number(states('sensor.solarflow_2_cell_max_vol')) }}
        state: >
          {% set min_v = states('sensor.solarflow_2_cell_min_vol') | float(0) %}
          {% set max_v = states('sensor.solarflow_2_cell_max_vol') | float(0) %}
          {{ [ (max_v - min_v) | round(3), 0 ] | max }}

      - name: "SolarFlow System Total Charge Power V24"
        unique_id: solarflow_system_total_charge_power_v24
        default_entity_id: sensor.solarflow_system_total_charge_power_v24
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >
          {% set solar = states('sensor.solarflow_total_solar_input') | float(0) %}
          {% set grid_in = states('sensor.solarflow_total_grid_input') | float(0) %}
          {% set output = states('sensor.solarflow_system_total_output') | float(0) %}
          {% set total_in = solar + grid_in %}
          {% set diff = total_in - output %}
          {{ diff if diff > 0 else 0 }}

      - name: "SolarFlow System Total Discharge Power V24"
        unique_id: solarflow_system_total_discharge_power_v24
        default_entity_id: sensor.solarflow_system_total_discharge_power_v24
        unit_of_measurement: "W"
        device_class: power
        state_class: measurement
        state: >
          {% set solar = states('sensor.solarflow_total_solar_input') | float(0) %}
          {% set grid_in = states('sensor.solarflow_total_grid_input') | float(0) %}
          {% set output = states('sensor.solarflow_system_total_output') | float(0) %}
          {% set total_in = solar + grid_in %}
          {% set diff = output - total_in %}
          {{ diff if diff > 0 else 0 }}

# ==============================================================================
# 4. ENERGY SENSORS
# ==============================================================================
sensor:
  - platform: integration
    source: sensor.solarflow_total_solar_input
    name: "SolarFlow System Solar Yield Total"
    unit_prefix: k
    method: left
    max_sub_interval:
      minutes: 1
    
  - platform: integration
    source: sensor.solarflow_system_total_charge_power_v24
    name: "SolarFlow System Battery In Total V24"
    unit_prefix: k
    method: left
    max_sub_interval:
      minutes: 1

  - platform: integration
    source: sensor.solarflow_system_total_discharge_power_v24
    name: "SolarFlow System Battery Out Total V24"
    unit_prefix: k
    method: left
    max_sub_interval:
      minutes: 1

# ==============================================================================
# 5. AUTOMATISIERUNGEN (V42.0 Diamond Logic)
# ==============================================================================
automation:
  # --- 6.1 SYNC ON STARTUP ---
  - alias: "Zendure: Sync Memory on Start"
    id: "zendure_sync_on_start"
    triggers:
      - trigger: homeassistant
        event: start
    actions:
      - delay:
          milliseconds: 500
      - if: 
          - condition: template
            # V42: Memory Guard: Do not sync if Sentinel (-2) is active!
            value_template: >
              {{ is_number(states('sensor.solarflow_1_output_limit'))
                 and (states('input_number.zendure_last_sent_1')|int(0) >= 0) }}
        then:
          - action: input_number.set_value
            target: { entity_id: input_number.zendure_last_sent_1 }
            data: { value: "{{ states('sensor.solarflow_1_output_limit')|int(0) }}" }
      - if: 
          - condition: template
            # V42: Memory Guard: Do not sync if Sentinel (-2) is active!
            value_template: >
              {{ is_number(states('sensor.solarflow_2_output_limit'))
                 and (states('input_number.zendure_last_sent_2')|int(0) >= 0) }}
        then:
          - action: input_number.set_value
            target: { entity_id: input_number.zendure_last_sent_2 }
            data: { value: "{{ states('sensor.solarflow_2_output_limit')|int(0) }}" }

  # --- 6.2 ANTI-DRIFT ---
  - alias: "Zendure: Anti-Drift Watchdog"
    id: "zendure_anti_drift_watchdog"
    mode: queued
    triggers:
      - trigger: template
        id: "drift_1"
        value_template: "{{ is_number(states('sensor.solarflow_1_output_limit')) and (states('sensor.solarflow_1_output_limit')|float(0) - states('input_number.zendure_last_sent_1')|float(0))|abs > 30 }}"
        for: "00:01:00"
      - trigger: template
        id: "drift_2"
        value_template: "{{ is_number(states('sensor.solarflow_2_output_limit')) and (states('sensor.solarflow_2_output_limit')|float(0) - states('input_number.zendure_last_sent_2')|float(0))|abs > 30 }}"
        for: "00:01:00"
    conditions:
      - condition: state
        entity_id: input_boolean.zendure_auto_mode
        state: "on"
      - condition: template
        value_template: >
          {% if trigger.id == 'drift_1' %}
            {{ states('input_number.zendure_last_sent_1')|float(0) >= 0 }}
          {% else %}
            {{ states('input_number.zendure_last_sent_2')|float(0) >= 0 }}
          {% endif %}
    actions:
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ trigger.id == 'drift_1' }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_1 }
                data: { value: "{{ states('sensor.solarflow_1_output_limit')|int }}" }
          - conditions:
              - condition: template
                value_template: "{{ trigger.id == 'drift_2' }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_2 }
                data: { value: "{{ states('sensor.solarflow_2_output_limit')|int }}" }

  # --- 6.2b SYNC MEMORY FROM MQTT ---
  - alias: "Zendure: Sync Memory from OutputLimit"
    id: "zendure_sync_memory_from_outputlimit"
    mode: queued
    triggers:
      - trigger: state
        entity_id:
          - sensor.solarflow_1_output_limit
          - sensor.solarflow_2_output_limit
    conditions:
      - condition: template
        value_template: >
          {{ is_number(trigger.to_state.state)
             and is_state('input_boolean.zendure_emergency_charge','off')
             and is_state('input_boolean.zendure_calib_mode_u1','off')
             and is_state('input_boolean.zendure_calib_mode_u2','off') }}
    actions:
      - choose:
          - conditions: "{{ trigger.entity_id == 'sensor.solarflow_1_output_limit' }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_1 }
                data: { value: "{{ trigger.to_state.state | int }}" }
          - conditions: "{{ trigger.entity_id == 'sensor.solarflow_2_output_limit' }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_2 }
                data: { value: "{{ trigger.to_state.state | int }}" }

  # --- 6.3 BYPASS LATCH MANAGER ---
  - alias: "Zendure: Bypass Latch Manager"
    id: "zendure_bypass_latch_manager"
    mode: single
    triggers:
      - trigger: state
        entity_id: [sensor.solarflow_1_battery_level, sensor.solarflow_2_battery_level]
      - trigger: homeassistant
        event: start
      - trigger: state
        entity_id: input_number.zendure_conf_soc_bypass
    actions:
      - variables:
          soc_entry: "{{ states('input_number.zendure_conf_soc_bypass') | int(30) }}"
          soc_exit: "{{ (soc_entry | int(30)) + 5 }}"
          soc1_ok: "{{ is_number(states('sensor.solarflow_1_battery_level')) }}"
          soc2_ok: "{{ is_number(states('sensor.solarflow_2_battery_level')) }}"
          soc1: "{{ states('sensor.solarflow_1_battery_level') | float(0) }}"
          soc2: "{{ states('sensor.solarflow_2_battery_level') | float(0) }}"
          
      - if: 
          - "{{ soc1_ok and soc1 <= soc_entry }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_bypass_u1 }
      - if: 
          - "{{ soc1_ok and soc1 >= soc_exit }}"
        then:
          - action: input_boolean.turn_off
            target: { entity_id: input_boolean.zendure_bypass_u1 }
            
      - if: 
          - "{{ soc2_ok and soc2 <= soc_entry }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_bypass_u2 }
      - if: 
          - "{{ soc2_ok and soc2 >= soc_exit }}"
        then:
          - action: input_boolean.turn_off
            target: { entity_id: input_boolean.zendure_bypass_u2 }

  # --- 6.4 CONTROL LOOP (BULLETPROOF EDITION) ---
  - alias: "Zendure: Control Loop (Dual)"
    id: "zendure_control_loop_dual"
    mode: single
    max_exceeded: silent
    triggers:
      - trigger: time_pattern
        seconds: "/5"
      - trigger: numeric_state
        entity_id: sensor.shellypro3em_SHELLY_ID_total_active_power
        above: 150
        for: "00:00:01"
      - trigger: numeric_state
        entity_id: sensor.shellypro3em_SHELLY_ID_total_active_power
        below: -30
        for: "00:00:01"
      - trigger: state
        entity_id: 
          - input_boolean.zendure_bypass_u1
          - input_boolean.zendure_bypass_u2
    conditions:
      - condition: state
        entity_id: input_boolean.zendure_auto_mode
        state: "on"
    actions:
      - variables:
          s1_ok: "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          s2_ok: "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          s1_base: "{{ [states('input_number.zendure_last_sent_1')|float(0)|int, 0]|max }}"
          s2_base: "{{ [states('input_number.zendure_last_sent_2')|float(0)|int, 0]|max }}"
          soc_off: "{{ states('input_number.zendure_conf_soc_off') | int(10) }}"
          hysteresis: "{{ states('input_number.zendure_conf_hysteresis') | int(10) }}"
          soc1_val: "{{ states('sensor.solarflow_1_battery_level') | float(0) }}"
          soc2_val: "{{ states('sensor.solarflow_2_battery_level') | float(0) }}"
          t1: "{{ states('sensor.solarflow_1_batt_max_temp') | float(states('sensor.solarflow_1_temp')|float(99)) }}"
          t2: "{{ states('sensor.solarflow_2_batt_max_temp') | float(states('sensor.solarflow_2_temp')|float(99)) }}"
          bypass1: "{{ is_state('input_boolean.zendure_bypass_u1','on') }}"
          bypass2: "{{ is_state('input_boolean.zendure_bypass_u2','on') }}"
          s1_solar: "{{ states('sensor.solarflow_1_solar_input') | float(0) if s1_ok else 0 }}"
          s2_solar: "{{ states('sensor.solarflow_2_solar_input') | float(0) if s2_ok else 0 }}"
          calib1: "{{ is_state('input_boolean.zendure_calib_mode_u1', 'on') }}"
          calib2: "{{ is_state('input_boolean.zendure_calib_mode_u2', 'on') }}"
          emerg_global: "{{ is_state('input_boolean.zendure_emergency_charge', 'on') }}"
          emerg_stop: "{{ states('input_number.zendure_conf_soc_emerg_stop') | int(20) }}"
          
          # Sentinel Check
          sentinel_u1: "{{ states('input_number.zendure_last_sent_1')|int(0) == -2 }}"
          sentinel_u2: "{{ states('input_number.zendure_last_sent_2')|int(0) == -2 }}"
          busy_u1: "{{ calib1 or sentinel_u1 or (emerg_global and soc1_val < emerg_stop) }}"
          busy_u2: "{{ calib2 or sentinel_u2 or (emerg_global and soc2_val < emerg_stop) }}"

          # Ghost Load
          ghost_load_1: "{{ s1_base if (not s1_ok and s1_base > 0) else 0 }}"
          ghost_load_2: "{{ s2_base if (not s2_ok and s2_base > 0) else 0 }}"
          ghost_total: "{{ ghost_load_1 + ghost_load_2 }}"

          cap_u1: >
            {% if not s1_ok or busy_u1 %}0
            {% elif t1 < 0 or t1 > 45 or soc1_val <= soc_off or bypass1 %}{{ (s1_solar * 0.9) | int(0) }}
            {% else %}800{% endif %}
          cap_u2: >
            {% if not s2_ok or busy_u2 %}0
            {% elif t2 < 0 or t2 > 45 or soc2_val <= soc_off or bypass2 %}{{ (s2_solar * 0.9) | int(0) }}
            {% else %}800{% endif %}
          
          safety_override: "{{ (s1_ok and s1_base > cap_u1|int) or (s2_ok and s2_base > cap_u2|int) }}"
          global_max: "{{ states('input_number.zendure_conf_max_output') | int(800) }}"
          
          # Available capacity for active units
          available_capacity: "{{ [ (global_max - ghost_total), 0 ] | max }}"

          failsafe: "{{ states('input_number.zendure_conf_failsafe_watt') | int(130) }}"
          grid_bias: "{{ states('input_number.zendure_conf_grid_bias') | int(10) }}"
          
          # Dynamic Min Change
          zen_mode: "{{ (bypass1 or bypass2) }}"
          slider_change: "{{ states('input_number.zendure_conf_min_change') | int(5) }}"
          min_change: "{{ (slider_change * 4) if zen_mode else slider_change }}"

          shelly_ok: "{{ is_number(states('sensor.shellypro3em_SHELLY_ID_total_active_power')) }}"
          grid: "{{ (states('sensor.shellypro3em_SHELLY_ID_total_active_power') | float(0)) if shelly_ok else 0 }}"
          total_base: "{{ (s1_base | int(0)) + (s2_base | int(0)) }}"
          
          target_raw: >-
            {{ ((total_base | int(0)) + (grid | float(0)) - (grid_bias | int(0)))
                if shelly_ok else (failsafe | int(0)) }}
          delta: "{{ (target_raw | float(0)) - (total_base | float(0)) }}"
          
          target_total: "{{ [[target_raw|int(0), 0]|max, global_max]|min }}"
          delta_effective: "{{ (target_total|int(0)) - (total_base|int(0)) }}"
      
      # Safety Gate
      - condition: template
        value_template: >
          {{ safety_override 
             or (delta_effective | abs > hysteresis | int(0))
             or (total_base | int(0) > global_max | int(0)) }}

      - variables:
          target_online: "{{ [[(target_total - ghost_total)|int(0), 0]|max, available_capacity]|min }}"
          
          soc1_valid: "{{ is_number(states('sensor.solarflow_1_battery_level')) }}"
          soc2_valid: "{{ is_number(states('sensor.solarflow_2_battery_level')) }}"
          active_1: "{{ s1_ok }}"
          active_2: "{{ s2_ok }}"
          weight_1: >-
            {% if soc1_valid and soc2_valid and (soc1_val + soc2_val) > 0 %}
              {{ soc1_val / (soc1_val + soc2_val) }}
            {% else %}
              0.5
            {% endif %}
          # Distribute 'target_online' to active units
          req_1: "{{ ((target_online | int(0)) * (weight_1 | float(0))) | int(0) }}"
          req_2: "{{ (target_online | int(0)) - (req_1 | int(0)) }}"
          
          # Spillover only if NOT busy
          floor_1: >-
            {% if soc1_val >= 98 and not busy_u1 %}
              {% if s1_solar > 400 %} 350
              {% elif s1_solar > 300 %} 250
              {% else %} 0 {% endif %}
            {% else %} 0 {% endif %}
          floor_2: >-
            {% if soc2_val >= 98 and not busy_u2 %}
              {% if s2_solar > 400 %} 350
              {% elif s2_solar > 300 %} 250
              {% else %} 0 {% endif %}
            {% else %} 0 {% endif %}
          
          req_1_final: "{{ [req_1|int(0), floor_1|int(0)]|max }}"
          req_2_final: "{{ [req_2|int(0), floor_2|int(0)]|max }}"
          final_1_init: "{{ [req_1_final|int(0), cap_u1|int(0)]|min }}"
          
          final_2_raw: >
            {% if active_2 %}
              {% set v = (req_2_final + (req_1_final - final_1_init)) | int(0) %}
              {{ [[v, 0] | max, cap_u2 | int(0)] | min }}
            {% else %}
              0
            {% endif %}
          
          final_1_raw: >
            {% if active_1 %}
              {% set v = (target_online | int(0)) - (final_2_raw | int(0)) %}
              {% set v_safe = [v, floor_1]|max %}
              {{ [[v_safe, 0] | max, cap_u1 | int(0)] | min }}
            {% else %}
              0
            {% endif %}
          
          # Scale ONLY Active Units within Available Capacity
          active_sum: >-
            {% set a1 = final_1_raw|int(0) if active_1 else 0 %}
            {% set a2 = final_2_raw|int(0) if active_2 else 0 %}
            {{ a1 + a2 }}
          
          scale_active: >-
            {% set cap = available_capacity|int(0) %}
            {% set s = active_sum|int(0) %}
            {% if s <= 0 %} 1
            {% elif cap <= 0 %} 0
            {% elif s > cap %} {{ cap / s }}
            {% else %} 1
            {% endif %}

          final_1: "{{ (final_1_raw|int(0) * scale_active) | int }}"
          final_2: "{{ (final_2_raw|int(0) * scale_active) | int }}"

      - parallel:
          - if: 
              - >-
                {{ s1_ok and not busy_u1 and (
                     ((final_1|int(0) - s1_base|int(0))|abs >= (min_change|int(0)))
                     or safety_override
                     or ((total_base|int(0) > global_max|int(0)) and (s1_base|int(0) > final_1|int(0)))
                   ) }}
            then:
              - action: mqtt.publish
                data:
                  topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit/set"
                  payload: "{{ final_1|int }}"
                  qos: 1
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_1 }
                data: { value: "{{ final_1|int }}" }

          - if: 
              - >-
                {{ s2_ok and not busy_u2 and (
                     ((final_2|int(0) - s2_base|int(0))|abs >= (min_change|int(0)) or safety_override
                     or ((total_base|int(0) > global_max|int(0)) and (s2_base|int(0) > final_2|int(0))))
                   ) }}
            then:
              - action: mqtt.publish
                data:
                  topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit/set"
                  payload: "{{ final_2|int }}"
                  qos: 1
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_last_sent_2 }
                data: { value: "{{ final_2|int }}" }

  # --- 6.5 STATE MACHINE (BULLETPROOF EDITION) ---
  - alias: "Zendure: State Machine (Smart Single-Channel)"
    id: "zendure_state_machine_dual"
    mode: queued
    triggers:
      - trigger: state
        entity_id: 
          - input_boolean.zendure_emergency_charge
          - input_boolean.zendure_calib_mode_u1
          - input_boolean.zendure_calib_mode_u2
        to: "on"
      - trigger: state
        entity_id: 
          - input_boolean.zendure_emergency_charge
          - input_boolean.zendure_calib_mode_u1
          - input_boolean.zendure_calib_mode_u2
        to: "off"
      - trigger: state
        entity_id: input_boolean.zendure_auto_mode
        to: "on"
      - trigger: state
        entity_id: input_boolean.zendure_auto_mode
        to: "off"
        id: "auto_off"
      - trigger: state
        entity_id: [sensor.solarflow_1_battery_level, sensor.solarflow_2_battery_level]
        for: "00:05:00"
      - trigger: template
        id: "device_online_u1"
        value_template: "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
      - trigger: template
        id: "device_online_u2"
        value_template: "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
      - trigger: homeassistant
        event: start
        id: "boot_check"
    actions:
      - choose:
          # AUTO-OFF FULL RESET (Flags off, Mode Output, Limit 0)
          - conditions: "{{ trigger.id == 'auto_off' }}"
            sequence:
              - action: input_boolean.turn_off
                target:
                  entity_id:
                    - input_boolean.zendure_emergency_charge
                    - input_boolean.zendure_calib_mode_u1
                    - input_boolean.zendure_calib_mode_u2
              
              - parallel:
                # UNIT 1 Reset
                - if:
                    - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/select/HUB1_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                    - action: mqtt.publish
                      data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                    - action: input_number.set_value
                      target: { entity_id: input_number.zendure_last_sent_1 }
                      data: { value: 0 }
                
                # UNIT 2 Reset
                - if:
                    - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/select/HUB2_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                    - action: mqtt.publish
                      data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                    - action: input_number.set_value
                      target: { entity_id: input_number.zendure_last_sent_2 }
                      data: { value: 0 }
              - stop: "Automatik beendet - Full Hard Reset."
          
          # DEVICE ONLINE & BOOT CHECK (SmartMode & Safety Reconnect)
          - conditions: "{{ trigger.id in ['device_online_u1', 'device_online_u2', 'boot_check'] }}"
            sequence:
              - delay: "00:00:05"
              
              # A) SmartMode Double Tap
              - parallel:
                - if: 
                    - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/switch/HUB1_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
                - if: 
                    - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/switch/HUB2_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
              - delay: "00:00:02"
              - parallel:
                - if: 
                    - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/switch/HUB1_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
                - if: 
                    - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
                  then:
                    - action: mqtt.publish
                      data: { topic: "Zendure/switch/HUB2_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }

              # B) V41 SAFETY RECONNECT: If Auto-Mode is OFF, force 0W + Output Mode + Reset Memory
              - if:
                  - "{{ is_state('input_boolean.zendure_auto_mode','off') }}"
                then:
                  - parallel:
                      - if:
                          - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
                        then:
                          - action: mqtt.publish
                            data: { topic: "Zendure/select/HUB1_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                          - action: mqtt.publish
                            data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                          # V42: Explicit memory reset to avoid ghost tracking
                          - action: input_number.set_value
                            target: { entity_id: input_number.zendure_last_sent_1 }
                            data: { value: 0 }
                            
                      - if:
                          - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable','unknown','FAULT','ERROR'] }}"
                        then:
                          - action: mqtt.publish
                            data: { topic: "Zendure/select/HUB2_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                          - action: mqtt.publish
                            data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                          # V42: Explicit memory reset
                          - action: input_number.set_value
                            target: { entity_id: input_number.zendure_last_sent_2 }
                            data: { value: 0 }
                  - stop: "Auto-Mode OFF: Safety Reconnect Hard-Stop applied."

      - variables:
          online1: "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          online2: "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          min_soc: 5
          t1: "{{ states('sensor.solarflow_1_batt_max_temp') | float(states('sensor.solarflow_1_temp')|float(99)) }}"
          t2: "{{ states('sensor.solarflow_2_batt_max_temp') | float(states('sensor.solarflow_2_temp')|float(99)) }}"
          soc1: "{{ states('sensor.solarflow_1_battery_level') | float(0) }}"
          soc2: "{{ states('sensor.solarflow_2_battery_level') | float(0) }}"
          cl1: "{% if t1 < 5 %} 100 {% elif t1 < 10 %} 300 {% else %} 800 {% endif %}"
          cl2: "{% if t2 < 5 %} 100 {% elif t2 < 10 %} 300 {% else %} 800 {% endif %}"
          sl1: "{% if soc1 > 97 %} 100 {% elif soc1 >= 90 %} 200 {% else %} 800 {% endif %}"
          sl2: "{% if soc2 > 97 %} 100 {% elif soc2 >= 90 %} 200 {% else %} 800 {% endif %}"
          ss1: "{% if soc1 < 12 %} 300 {% else %} 800 {% endif %}"
          ss2: "{% if soc2 < 12 %} 300 {% else %} 800 {% endif %}"
          charge_limit_u1: "{{ [cl1|int, sl1|int, ss1|int]|min }}"
          limit_emerg_u1: "{{ [300, cl1|int, ss1|int]|min }}"
          limit_calib_u1: "{{ [cl1|int, sl1|int]|min }}"
          charge_limit_u2: "{{ [cl2|int, sl2|int, ss2|int]|min }}"
          limit_emerg_u2: "{{ [300, cl2|int, ss2|int]|min }}"
          limit_calib_u2: "{{ [cl2|int, sl2|int]|min }}"
          curr_min_soc_1: "{{ states('sensor.solarflow_1_setting_minsoc') | int(-1) }}"
          curr_charge_1: "{{ states('sensor.solarflow_1_setting_chargelimit') | int(-1) }}"
          curr_min_soc_2: "{{ states('sensor.solarflow_2_setting_minsoc') | int(-1) }}"
          curr_charge_2: "{{ states('sensor.solarflow_2_setting_chargelimit') | int(-1) }}"
          emerg_global: "{{ is_state('input_boolean.zendure_emergency_charge', 'on') }}"
          emerg_stop: "{{ states('input_number.zendure_conf_soc_emerg_stop') | int(20) }}"

      - if: "{{ is_state('input_boolean.zendure_auto_mode','on') }}"
        then:
          - parallel:
            - if: 
                - "{{ online1 and (curr_min_soc_1 != min_soc|int or curr_charge_1 != charge_limit_u1|int) }}"
              then:
                - action: mqtt.publish
                  data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/minSoc/set", payload: "{{ min_soc }}", qos: 1 }
                - action: mqtt.publish
                  data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/chargeMaxLimit/set", payload: "{{ charge_limit_u1 }}", qos: 1 }
            - if: 
                - "{{ online2 and (curr_min_soc_2 != min_soc|int or curr_charge_2 != charge_limit_u2|int) }}"
              then:
                - action: mqtt.publish
                  data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/minSoc/set", payload: "{{ min_soc }}", qos: 1 }
                - action: mqtt.publish
                  data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/chargeMaxLimit/set", payload: "{{ charge_limit_u2 }}", qos: 1 }
      
      - parallel:
          # --- UNIT 1 LOGIC ---
          - sequence:
              - if: 
                  - "{{ is_state('input_boolean.zendure_calib_mode_u1','on') and online1 }}"
                then:
                  # Force Charge (Input mode)
                  - action: mqtt.publish
                    data: { topic: "Zendure/select/HUB1_SERIAL_NUMBER/acMode/set", payload: "Input mode", qos: 1 }
                  # Force Output 0
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/inputLimit/set", payload: "{{ limit_calib_u1 }}", qos: 1 }
                  - action: input_number.set_value
                    target: { entity_id: input_number.zendure_last_sent_1 }
                    data: { value: -2 }
              
              - if: 
                  - "{{ emerg_global and is_state('input_boolean.zendure_calib_mode_u1','off') and online1 and soc1 < emerg_stop }}"
                then:
                  - action: mqtt.publish
                    data: { topic: "Zendure/select/HUB1_SERIAL_NUMBER/acMode/set", payload: "Input mode", qos: 1 }
                  # Force Output 0
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB1_SERIAL_NUMBER/inputLimit/set", payload: "{{ limit_emerg_u1 }}", qos: 1 }
                  - action: input_number.set_value
                    target: { entity_id: input_number.zendure_last_sent_1 }
                    data: { value: -2 }

              # Return to Normal Mode
              - if: 
                  - >
                    {{ (is_state('input_boolean.zendure_calib_mode_u1','off') 
                        and (not emerg_global or soc1 >= emerg_stop)
                        and online1
                        and states('input_number.zendure_last_sent_1')|int(0) == -2 ) }}
                then:
                   - action: mqtt.publish
                     data: { topic: "Zendure/select/HUB1_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                   - action: input_number.set_value
                     target: { entity_id: input_number.zendure_last_sent_1 }
                     data: { value: 0 }
                   - delay: "00:00:01" 

          # --- UNIT 2 LOGIC ---
          - sequence:
              - if: 
                  - "{{ is_state('input_boolean.zendure_calib_mode_u2','on') and online2 }}"
                then:
                  - action: mqtt.publish
                    data: { topic: "Zendure/select/HUB2_SERIAL_NUMBER/acMode/set", payload: "Input mode", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/inputLimit/set", payload: "{{ limit_calib_u2 }}", qos: 1 }
                  - action: input_number.set_value
                    target: { entity_id: input_number.zendure_last_sent_2 }
                    data: { value: -2 }
              
              - if: 
                  - "{{ emerg_global and is_state('input_boolean.zendure_calib_mode_u2','off') and online2 and soc2 < emerg_stop }}"
                then:
                  - action: mqtt.publish
                    data: { topic: "Zendure/select/HUB2_SERIAL_NUMBER/acMode/set", payload: "Input mode", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/outputLimit/set", payload: "0", qos: 1 }
                  - action: mqtt.publish
                    data: { topic: "Zendure/number/HUB2_SERIAL_NUMBER/inputLimit/set", payload: "{{ limit_emerg_u2 }}", qos: 1 }
                  - action: input_number.set_value
                    target: { entity_id: input_number.zendure_last_sent_2 }
                    data: { value: -2 }

              # Return to Normal Mode
              - if: 
                  - >
                    {{ (is_state('input_boolean.zendure_calib_mode_u2','off') 
                        and (not emerg_global or soc2 >= emerg_stop)
                        and online2
                        and states('input_number.zendure_last_sent_2')|int(0) == -2 ) }}
                then:
                   - action: mqtt.publish
                     data: { topic: "Zendure/select/HUB2_SERIAL_NUMBER/acMode/set", payload: "Output mode", qos: 1 }
                   - action: input_number.set_value
                     target: { entity_id: input_number.zendure_last_sent_2 }
                     data: { value: 0 }
                   - delay: "00:00:01"

  # --- 6.6 CALIBRATION MANAGER (V36: Daytime Sag & Natural Full Charge) ---
  - alias: "Zendure: Smart Calibration Manager"
    id: "zendure_calibration_manager"
    mode: queued
    triggers:
      - trigger: time
        at: "13:00:00"
        id: "check_time"
      - trigger: template
        id: "sag_u1"
        value_template: "{{ states('sensor.solarflow_1_cell_min_vol')|float(3.3) < 3.0 and states('sensor.solarflow_1_battery_level')|float(0) > 15 }}"
        for: "00:00:30"
      - trigger: template
        id: "sag_u2"
        value_template: "{{ states('sensor.solarflow_2_cell_min_vol')|float(3.3) < 3.0 and states('sensor.solarflow_2_battery_level')|float(0) > 15 }}"
        for: "00:00:30"
      - trigger: numeric_state
        entity_id: sensor.solarflow_1_battery_level
        above: 99
        for: "00:05:00"
        id: "stop_u1"
      - trigger: numeric_state
        entity_id: sensor.solarflow_2_battery_level
        above: 99
        for: "00:05:00"
        id: "stop_u2"
      - trigger: numeric_state
        entity_id: sensor.solarflow_1_battery_level
        above: 99
        id: "natural_full_u1"
      - trigger: numeric_state
        entity_id: sensor.solarflow_2_battery_level
        above: 99
        id: "natural_full_u2"
    conditions:
      - condition: state
        entity_id: input_boolean.zendure_auto_mode
        state: "on"
    actions:
      - variables:
          last_u1: "{{ as_timestamp(states('input_datetime.zendure_last_full_charge_1'), default=0) }}"
          last_u2: "{{ as_timestamp(states('input_datetime.zendure_last_full_charge_2'), default=0) }}"
          days_cfg: "{{ states('input_number.zendure_conf_calib_days') | int(14) }}"
          days_u1: "{{ ((as_timestamp(now()) - last_u1) / 86400) | int(0) }}"
          days_u2: "{{ ((as_timestamp(now()) - last_u2) / 86400) | int(0) }}"
      
      - if: 
          - "{{ trigger.id == 'stop_u1' or trigger.id == 'natural_full_u1' }}"
        then:
          - action: input_datetime.set_datetime
            target: { entity_id: input_datetime.zendure_last_full_charge_1 }
            data: { timestamp: "{{ as_timestamp(now()) }}" }
      
      - if: 
          - "{{ trigger.id == 'stop_u2' or trigger.id == 'natural_full_u2' }}"
        then:
          - action: input_datetime.set_datetime
            target: { entity_id: input_datetime.zendure_last_full_charge_2 }
            data: { timestamp: "{{ as_timestamp(now()) }}" }

      - if: 
          - "{{ trigger.id == 'check_time' and days_u1 > days_cfg and is_state('input_boolean.zendure_calib_mode_u1', 'off') }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_calib_mode_u1 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "📅 *Kalibrierung U1*\nGestartet (Zeit-Trigger: {{ days_u1 }} Tage)." }
      
      # V36: Sag Trigger restricted to daytime (10-15h)
      - if: 
          - "{{ trigger.id == 'sag_u1' and is_state('input_boolean.zendure_calib_mode_u1', 'off') and 10 <= now().hour < 15 }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_calib_mode_u1 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "📉 *Not-Kalibrierung U1*\nSpannungseinbruch erkannt (Voltage Sag)!" }

      - if: 
          - "{{ trigger.id == 'check_time' and days_u2 > days_cfg and is_state('input_boolean.zendure_calib_mode_u2', 'off') }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_calib_mode_u2 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "📅 *Kalibrierung U2*\nGestartet (Zeit-Trigger: {{ days_u2 }} Tage)." }
      
      # V36: Sag Trigger restricted to daytime (10-15h)
      - if: 
          - "{{ trigger.id == 'sag_u2' and is_state('input_boolean.zendure_calib_mode_u2', 'off') and 10 <= now().hour < 15 }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: input_boolean.zendure_calib_mode_u2 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "📉 *Not-Kalibrierung U2*\nSpannungseinbruch erkannt (Voltage Sag)!" }

      - if: 
          - "{{ trigger.id == 'stop_u1' and is_state('input_boolean.zendure_calib_mode_u1','on') }}"
        then:
          - action: input_boolean.turn_off
            target: { entity_id: input_boolean.zendure_calib_mode_u1 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "✅ *Kalibrierung U1*\nErfolgreich beendet (100%)." }

      - if: 
          - "{{ trigger.id == 'stop_u2' and is_state('input_boolean.zendure_calib_mode_u2','on') }}"
        then:
          - action: input_boolean.turn_off
            target: { entity_id: input_boolean.zendure_calib_mode_u2 }
          - action: notify.send_message
            target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
            data: { message: "✅ *Kalibrierung U2*\nErfolgreich beendet (100%)." }

  # --- 6.7 HEALTH REPORTER ---
  - alias: "Zendure: Weekly Health Report"
    id: "zendure_weekly_report"
    triggers:
      - trigger: time
        at: "18:00:00"
    conditions:
      - condition: time
        weekday: [fri]
    actions:
      - variables:
          last_u1: "{{ as_timestamp(states('input_datetime.zendure_last_full_charge_1'), default=0) }}"
          last_u2: "{{ as_timestamp(states('input_datetime.zendure_last_full_charge_2'), default=0) }}"
          days_u1: "{{ ((as_timestamp(now()) - last_u1) / 86400) | int(0) }}"
          days_u2: "{{ ((as_timestamp(now()) - last_u2) / 86400) | int(0) }}"
          imb1_raw: "{{ states('sensor.solarflow_1_cell_imbalance') }}"
          imb2_raw: "{{ states('sensor.solarflow_2_cell_imbalance') }}"
      - action: notify.send_message
        target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
        data:
          message: >
            ℹ️ *Zendure Wochenbericht*
            Unit 1: {{ days_u1 }} Tage ({{ imb1_raw }} V)
            Unit 2: {{ days_u2 }} Tage ({{ imb2_raw }} V)

  # --- 6.8b AUTO-EMERGENCY MANAGER (V42: System-Wide STOP) ---
  - alias: "Zendure: Auto-Emergency Manager"
    id: "zendure_auto_emergency_manager"
    triggers:
      - trigger: time_pattern
        minutes: "/30"
      
      - trigger: numeric_state
        id: "solar_stable_stop"
        entity_id: sensor.solarflow_total_solar_input
        above: 200
        for: "00:05:00"
      
      # V42: NEW STOP TRIGGER (Checks if MINIMUM of all available SoCs > limit)
      - trigger: template
        id: "stop_min_soc"
        value_template: >
          {% set stop = states('input_number.zendure_conf_soc_emerg_stop')|float(20) %}
          {% set s1 = states('sensor.solarflow_1_battery_level')|float(-1) %}
          {% set s2 = states('sensor.solarflow_2_battery_level')|float(-1) %}
          {% set vals = [] %}
          {% if s1 >= 0 %}{% set vals = vals + [s1] %}{% endif %}
          {% if s2 >= 0 %}{% set vals = vals + [s2] %}{% endif %}
          {{ vals|length > 0 and (vals|min) >= stop }}
        for: "00:02:00"
      
      # V36: Start Condition (Low Solar + Low Battery for 10 min)
      - trigger: template
        id: "stable_start_u1"
        value_template: >
          {{ is_number(states('sensor.solarflow_1_battery_level')) 
             and states('sensor.solarflow_1_battery_level')|float(0) < states('input_number.zendure_conf_soc_emerg_start')|float(15)
             and states('sensor.solarflow_total_solar_input')|float(0) < 150 }}
        for: "00:10:00"
      - trigger: template
        id: "stable_start_u2"
        value_template: >
          {{ is_number(states('sensor.solarflow_2_battery_level')) 
             and states('sensor.solarflow_2_battery_level')|float(0) < states('input_number.zendure_conf_soc_emerg_start')|float(15)
             and states('sensor.solarflow_total_solar_input')|float(0) < 150 }}
        for: "00:10:00"

    conditions:
      - condition: state
        entity_id: input_boolean.zendure_auto_mode
        state: "on"
    actions:
      - variables:
          s1: "{{ states('sensor.solarflow_1_battery_level')|float(-1) }}"
          s2: "{{ states('sensor.solarflow_2_battery_level')|float(-1) }}"
          valid_socs: >
            {% set list = [] %}
            {% if s1 >= 0 %}{% set list = list + [s1] %}{% endif %}
            {% if s2 >= 0 %}{% set list = list + [s2] %}{% endif %}
            {{ list }}
          min_soc_val: "{{ valid_socs | min if valid_socs | length > 0 else 100 }}"
          solar: "{{ states('sensor.solarflow_total_solar_input')|float(0) }}"
          start_lim: "{{ states('input_number.zendure_conf_soc_emerg_start')|int }}"
          stop_lim: "{{ states('input_number.zendure_conf_soc_emerg_stop')|int }}"
      
      - choose:
          # V36: Start only if stable trigger fired OR manually if somehow missed (fallback)
          - conditions: "{{ (trigger.id == 'stable_start_u1' or trigger.id == 'stable_start_u2') and is_state('input_boolean.zendure_emergency_charge', 'off') }}"
            sequence:
              - action: input_boolean.turn_on
                target: { entity_id: input_boolean.zendure_emergency_charge }
              - action: notify.send_message
                target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
                data: 
                  message: "🔋 *Zendure Notladung*\nGestartet (Min SoC: {{ min_soc_val|round(0) }}% < {{ start_lim }}%)."
          
          # V42: Stop logic bound to system-wide minimum SOC
          - conditions: "{{ trigger.id in ['stop_min_soc', 'solar_stable_stop'] }}"
            sequence:
              - if: 
                  - "{{ is_state('input_boolean.zendure_emergency_charge','on') }}"
                then:
                  - action: input_boolean.turn_off
                    target: { entity_id: input_boolean.zendure_emergency_charge }
                  - action: notify.send_message
                    target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
                    data: { message: "✅ *Zendure Notladung*\nBeendet." }

  # --- 6.9 SEASON MANAGER (SPORT SETTINGS & FIXED 14D CALIB) ---
  - alias: "Zendure: Season Manager"
    id: "zendure_season_manager_dual"
    triggers:
      - trigger: time
        at: "04:00:00"
      - trigger: homeassistant
        event: start
    actions:
      - choose:
          # WINTER (Oktober - März)
          - conditions: "{{ now().month >= 10 or now().month < 4 }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_off }
                data: { value: 20 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_bypass }
                data: { value: 25 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_emerg_start }
                data: { value: 15 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_emerg_stop }
                data: { value: 25 }
              # V37.1: FIXED 14 Days (User Request)
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_calib_days }
                data: { value: 14 }

          # SOMMER (April - September)
          - conditions: "{{ now().month >= 4 and now().month < 10 }}"
            sequence:
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_off }
                data: { value: 10 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_bypass }
                data: { value: 15 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_emerg_start }
                data: { value: 7 }
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_soc_emerg_stop }
                data: { value: 9 }
              # V37.1: FIXED 14 Days (User Request)
              - action: input_number.set_value
                target: { entity_id: input_number.zendure_conf_calib_days }
                data: { value: 14 }
      
      # V36: Base settings (Dynamic Hysteresis is handled in Control Loop)
      - action: input_number.set_value
        target: { entity_id: input_number.zendure_conf_grid_bias }
        data: { value: 10 }
      - action: input_number.set_value
        target: { entity_id: input_number.zendure_conf_hysteresis }
        data: { value: 10 }
      - action: input_number.set_value
        target: { entity_id: input_number.zendure_conf_min_change }
        data: { value: 5 }

      - delay: "00:00:05"
      # V39: Double-Tap SmartMode ON (SWITCH PROTOCOL "ON")
      - parallel:
        - if: 
            - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          then:
            - action: mqtt.publish
              data: { topic: "Zendure/switch/HUB1_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
        - if: 
            - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          then:
            - action: mqtt.publish
              data: { topic: "Zendure/switch/HUB2_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
      - delay: "00:00:02" # Safety Delay
      - parallel:
        - if: 
            - "{{ states('sensor.solarflow_1_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          then:
            - action: mqtt.publish
              data: { topic: "Zendure/switch/HUB1_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }
        - if: 
            - "{{ states('sensor.solarflow_2_status_raw') not in ['unavailable', 'unknown', 'FAULT', 'ERROR'] }}"
          then:
            - action: mqtt.publish
              data: { topic: "Zendure/switch/HUB2_SERIAL_NUMBER/smartMode/set", payload: "ON", qos: 1 }

  # --- 6.10 MONITORING ---
  - alias: "Zendure: Monitoring"
    id: "zendure_monitoring_dual"
    triggers:
      - trigger: template
        id: "shelly_fail"
        value_template: "{{ not is_number(states('sensor.shellypro3em_SHELLY_ID_total_active_power')) }}"
        for: "00:00:30"
      - trigger: template
        id: "shelly_ok"
        value_template: "{{ is_number(states('sensor.shellypro3em_SHELLY_ID_total_active_power')) }}"
        for: "00:01:00"
      - trigger: state
        entity_id: sensor.solarflow_1_status_raw
        to: "unavailable"
        for: "00:03:00" # V40: Reduced to 3m (total 5m with expiry)
        id: "u1_fail"
      - trigger: state
        entity_id: sensor.solarflow_2_status_raw
        to: "unavailable"
        for: "00:03:00" # V40: Reduced to 3m
        id: "u2_fail"
    actions:
      - choose:
          - conditions: "{{ trigger.id == 'shelly_fail' }}"
            sequence:
              - action: persistent_notification.create
                data: { title: "⚠️ Zendure Failsafe", message: "Netzdaten fehlen (Shelly offline). Grundlast aktiv.", notification_id: "sf_failsafe" }
          - conditions: "{{ trigger.id == 'shelly_ok' }}"
            sequence:
              - action: persistent_notification.dismiss
                data: { notification_id: "sf_failsafe" }
          - conditions: "{{ trigger.id == 'u1_fail' }}"
            sequence:
              - action: notify.send_message
                target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
                data: { message: "⚠️ *Zendure Warnung*\nUnit 1 ist offline/nicht erreichbar." }
          - conditions: "{{ trigger.id == 'u2_fail' }}"
            sequence:
              - action: notify.send_message
                target: { entity_id: notify.telegram_bot_YOUR_TELEGRAM_SERVICE }
                data: { message: "⚠️ *Zendure Warnung*\nUnit 2 ist offline/nicht erreichbar." }
